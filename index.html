<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöå Sistema de Rutas de Transporte Escolar - MINEDEC Ecuador</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --yellow: #fcd116;
            --blue: #003893;
            --red: #ce1126;
            --dark-bg: #0a1628;
            --card-bg: rgba(15, 30, 55, 0.95);
            --text-light: #e8f0ff;
            --text-muted: #8ba3c7;
            --success: #10b981;
            --warning: #f59e0b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, var(--dark-bg) 0%, #1a365d 50%, var(--dark-bg) 100%);
            min-height: 100vh;
            color: var(--text-light);
        }

        .header {
            background: linear-gradient(90deg, var(--yellow) 0%, var(--yellow) 33%, var(--blue) 33%, var(--blue) 66%, var(--red) 66%, var(--red) 100%);
            height: 6px;
        }

        .header-content {
            background: var(--card-bg);
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(252, 209, 22, 0.2);
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-section h1 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--yellow);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-section h1 .logo-img {
            height: 60px;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .logo-section span {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .main-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            height: calc(100vh - 90px);
        }

        .sidebar {
            background: var(--card-bg);
            border-right: 1px solid rgba(252, 209, 22, 0.2);
            overflow-y: auto;
            padding: 15px;
        }

        .section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--yellow);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-area {
            border: 2px dashed rgba(252, 209, 22, 0.4);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(252, 209, 22, 0.05);
        }

        .upload-area:hover {
            border-color: var(--yellow);
            background: rgba(252, 209, 22, 0.1);
        }

        .upload-area.dragover {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }

        .upload-area input[type="file"] { display: none; }
        .upload-icon { font-size: 2rem; margin-bottom: 8px; }
        .upload-text { font-size: 0.8rem; color: var(--text-muted); }
        .upload-text strong { color: var(--yellow); }

        .btn {
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-size: 0.8rem;
        }

        .btn-primary { background: var(--yellow); color: var(--dark-bg); }
        .btn-primary:hover { background: #e5bc00; }
        .btn-secondary { background: transparent; color: var(--yellow); border: 1px solid var(--yellow); }
        .btn-secondary:hover { background: rgba(252, 209, 22, 0.1); }
        .btn-success { background: var(--success); color: white; }
        .btn-danger { background: var(--red); color: white; }
        .btn-block { width: 100%; }
        .btn-sm { padding: 5px 10px; font-size: 0.7rem; }

        #map { width: 100%; height: 100%; }

        .ie-info {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05));
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 10px;
            padding: 12px;
        }

        .ie-info h3 { color: var(--success); font-size: 0.85rem; margin-bottom: 8px; }
        .ie-info p { font-size: 0.75rem; color: var(--text-muted); margin: 4px 0; }
        .ie-info .coords { font-family: monospace; font-size: 0.7rem; color: var(--yellow); }

        .route-list { max-height: 280px; overflow-y: auto; }

        .route-item {
            background: rgba(252, 209, 22, 0.05);
            border: 1px solid rgba(252, 209, 22, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .route-item:hover {
            border-color: var(--yellow);
            background: rgba(252, 209, 22, 0.1);
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .route-number { font-weight: 600; font-size: 0.9rem; }

        .route-mode-tag {
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.6);
            color: #a7f3d0;
        }

        .route-actions { display: flex; gap: 4px; }

        .route-delete {
            background: none;
            border: none;
            color: var(--red);
            cursor: pointer;
            font-size: 1rem;
            padding: 2px 6px;
        }

        .route-edit {
            background: none;
            border: none;
            color: var(--primary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 6px;
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
        }
        .route-edit:hover { 
            opacity: 1;
            transform: scale(1.1);
        }

        /* Estilos para marcadores de v√©rtices editables */
        .vertex-marker {
            cursor: move !important;
            transition: transform 0.2s;
        }
        .vertex-marker:hover {
            transform: scale(1.2);
        }
        .vertex-marker:active {
            cursor: grabbing !important;
        }

        .route-info { font-size: 0.7rem; color: var(--text-muted); }
        .route-info span { display: block; margin-bottom: 2px; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stat-card {
            background: rgba(252, 209, 22, 0.08);
            border: 1px solid rgba(252, 209, 22, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-value { font-size: 1.3rem; font-weight: 700; color: var(--yellow); }
        .stat-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: transparent;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .modal-overlay.active { 
            opacity: 1; 
            visibility: visible;
        }

        .modal {
            position: absolute;
            pointer-events: auto;
            background: linear-gradient(135deg, rgba(15, 30, 55, 0.98), rgba(10, 22, 40, 0.98));
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 25px;
            max-width: 650px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid rgba(252, 209, 22, 0.6);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.9),
                0 0 0 1px rgba(252, 209, 22, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: none; /* Desactivar transici√≥n para movimiento suave */
        }

        .modal-overlay.active .modal { 
            /* Posici√≥n inicial centrada */
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            cursor: grab;
            user-select: none;
            padding: 5px 0;
            border-bottom: 1px solid rgba(252, 209, 22, 0.2);
            padding-bottom: 10px;
        }

        .modal-header:active {
            cursor: grabbing;
        }

        .modal-header::before {
            content: '‚ãÆ‚ãÆ';
            position: absolute;
            left: 10px;
            color: var(--text-muted);
            font-size: 1.2rem;
            opacity: 0.5;
        }

        .modal-title { 
            font-size: 1.1rem; 
            font-weight: 600; 
            color: var(--yellow);
            flex: 1;
            text-align: center;
            pointer-events: none;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s;
            pointer-events: auto;
        }

        .modal-close:hover {
            color: var(--red);
        }

        /* Indicador visual de que es arrastrable */
        .drag-handle-indicator {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(252, 209, 22, 0.8);
            color: var(--dark-bg);
            padding: 2px 12px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .modal:hover .drag-handle-indicator {
            opacity: 1;
        }

        .form-group { margin-bottom: 15px; }
        
        .form-label { 
            display: block; 
            font-size: 0.75rem; 
            color: var(--text-muted); 
            margin-bottom: 5px; 
            font-weight: 500;
        }
        
        /* Indicador visual para campos requeridos */
        .form-label:has(+ input[required])::after,
        label.form-label:contains("*")::after {
            content: "";
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #ef4444;
            border-radius: 50%;
            margin-left: 4px;
            vertical-align: middle;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(252, 209, 22, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            font-family: 'Poppins', sans-serif;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .form-input:focus { 
            outline: none; 
            border-color: var(--yellow);
            box-shadow: 0 0 0 3px rgba(252, 209, 22, 0.1);
        }
        
        /* Placeholder m√°s visible */
        .form-input::placeholder {
            color: rgba(148, 163, 184, 0.5);
            font-size: 0.8rem;
        }
        
        /* Campos requeridos vac√≠os con borde rojo sutil */
        .form-input:required:invalid {
            border-color: rgba(239, 68, 68, 0.3);
        }
        
        /* Estado de error */
        .form-input.error {
            border-color: #ef4444;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
            animation: shake 0.3s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
            color: var(--text-light);
            font-family: 'Poppins', sans-serif;
            font-size: 0.85rem;
        }

        .form-input:focus { outline: none; border-color: var(--yellow); }

        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }

        .coord-section {
            background: rgba(252, 209, 22, 0.05);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 12px;
            border-left: 3px solid var(--yellow);
        }

        .coord-section.coord-dest {
            border-left-color: var(--success);
            background: rgba(16, 185, 129, 0.05);
        }

        .coord-section-title { font-size: 0.8rem; font-weight: 600; margin-bottom: 10px; }

        /* ==================== POINT SYSTEM STYLES ==================== */
        .point-system-section {
            background: rgba(59, 130, 246, 0.05);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .point-system-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .current-coord-panel {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .point-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .fixed-points-panel {
            background: rgba(16, 185, 129, 0.05);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
        }

        .fixed-points-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(16, 185, 129, 0.2);
        }

        .fixed-points-list {
            max-height: 200px;
            overflow-y: auto;
        }

        /* ==================== BATCH ROUTES STYLES ==================== */
        .batch-routes-panel {
            background: rgba(252, 209, 22, 0.05);
            border: 2px solid rgba(252, 209, 22, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .batch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(252, 209, 22, 0.2);
        }

        .batch-routes-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .batch-route-item {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(252, 209, 22, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .batch-route-item:hover {
            background: rgba(252, 209, 22, 0.1);
            border-color: rgba(252, 209, 22, 0.5);
        }

        .batch-route-item:last-child {
            margin-bottom: 0;
        }

        .batch-route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .batch-route-number {
            font-weight: 700;
            font-size: 1rem;
            color: var(--yellow);
        }

        .batch-route-info {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
        }

        .batch-route-remove {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #ef4444;
            cursor: pointer;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.7rem;
            transition: all 0.2s;
        }

        .batch-route-remove:hover {
            background: #ef4444;
            color: white;
        }

        .batch-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .fixed-point-item {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.2);
            border-radius: 6px;
            padding: 8px 10px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .fixed-point-item:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.4);
        }

        .fixed-point-item:last-child {
            margin-bottom: 0;
        }

        .point-label {
            font-weight: 600;
            color: #34d399;
        }

        .point-coords {
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
        }

        .point-remove {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            font-size: 1rem;
            padding: 0 5px;
            transition: transform 0.2s;
        }

        .point-remove:hover {
            transform: scale(1.2);
        }

        .drawing-tools {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-top: 10px;
        }

        /* Estilos para marcadores de puntos fijados */
        .fixed-point-marker {
            background: #10b981;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            color: white;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.6);
            cursor: grab;
            transition: all 0.2s;
        }

        .fixed-point-marker:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.8);
        }

        .fixed-point-marker.dragging {
            cursor: grabbing;
            transform: scale(1.3);
        }

        .fixed-point-marker.origin {
            background: #fcd116;
            border-color: #fff;
            box-shadow: 0 2px 8px rgba(252, 209, 22, 0.6);
        }

        .fixed-point-marker.destination {
            background: #ef4444;
            border-color: #fff;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.6);
        }

        /* Preview marker temporal */
        .preview-marker {
            background: rgba(59, 130, 246, 0.7);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            animation: pulse-preview 1.5s ease-in-out infinite;
        }

        @keyframes pulse-preview {
            0%, 100% {
                transform: scale(1);
                opacity: 0.7;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .loading {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 22, 40, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading.show { opacity: 1; visibility: visible; }

        .spinner {
            width: 50px; height: 50px;
            border: 4px solid rgba(252, 209, 22, 0.2);
            border-top-color: var(--yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-text { margin-top: 15px; color: var(--text-light); }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 10px;
            color: white;
            font-size: 0.85rem;
            z-index: 3001;
            transform: translateX(150%);
            transition: transform 0.3s ease;
            max-width: 350px;
        }

        .notification.show { transform: translateX(0); }
        .notification.success { background: linear-gradient(135deg, #10b981, #059669); }
        .notification.error { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .notification.info { background: linear-gradient(135deg, #3b82f6, #2563eb); }

        .drawing-toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3500;
            background: rgba(15, 30, 55, 0.98);
            border-radius: 12px;
            border: 2px solid var(--yellow);
            padding: 12px 20px;
            display: none;
            align-items: center;
            gap: 15px;
            font-size: 0.85rem;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.6);
        }

        .drawing-toolbar span { color: var(--yellow); font-weight: 600; }
        .drawing-toolbar .hint { color: var(--text-muted); font-size: 0.7rem; font-weight: normal; }

        .debug-panel {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--yellow);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.65rem;
            color: #0f0;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .debug-panel.show { display: block; }

        /* ==================== LAT LON TOOLS STYLES ==================== */
        .latlon-tools-panel {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .latlon-tools-panel .section-title {
            color: #60a5fa;
            margin-bottom: 12px;
        }

        .latlon-tools-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
        }

        .latlon-tab {
            flex: 1;
            padding: 6px 8px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .latlon-tab:hover {
            background: rgba(59, 130, 246, 0.2);
            color: var(--text-light);
        }

        .latlon-tab.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
            color: #60a5fa;
        }

        .latlon-content {
            display: none;
        }

        .latlon-content.active {
            display: block;
        }

        .coord-display {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .coord-display-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .coord-display-row:last-child {
            border-bottom: none;
        }

        .coord-label {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .coord-value {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            color: #60a5fa;
            cursor: pointer;
            transition: color 0.2s;
        }

        .coord-value:hover {
            color: var(--yellow);
        }

        .converter-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .converter-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .converter-results {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 0.7rem;
        }

        .result-label {
            color: var(--text-muted);
        }

        .result-value {
            font-family: 'Courier New', monospace;
            color: #60a5fa;
            cursor: pointer;
        }

        .result-value:hover {
            color: var(--yellow);
        }

        .latlon-btn-group {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .latlon-btn {
            flex: 1;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid;
        }

        .latlon-btn-primary {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6;
            color: #60a5fa;
        }

        .latlon-btn-primary:hover {
            background: rgba(59, 130, 246, 0.4);
        }

        .latlon-btn-success {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #34d399;
        }

        .latlon-btn-success:hover {
            background: rgba(16, 185, 129, 0.4);
        }

        .cursor-coords-bar {
            position: fixed;
            bottom: 10px;
            left: 400px;
            background: rgba(15, 30, 55, 0.95);
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 8px;
            padding: 8px 15px;
            display: flex;
            gap: 20px;
            font-size: 0.7rem;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .cursor-coord-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .cursor-coord-label {
            color: var(--text-muted);
        }

        .cursor-coord-value {
            font-family: 'Courier New', monospace;
            color: #60a5fa;
            min-width: 100px;
        }

        .capture-mode-active {
            border-color: var(--yellow) !important;
            animation: pulse-border 1.5s infinite;
        }

        @keyframes pulse-border {
            0%, 100% { box-shadow: 0 0 0 0 rgba(252, 209, 22, 0.4); }
            50% { box-shadow: 0 0 0 4px rgba(252, 209, 22, 0.2); }
        }

        .zoom-marker {
            background: rgba(252, 209, 22, 0.9);
            border: 3px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .format-select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            font-size: 0.75rem;
            margin-bottom: 8px;
        }

        .capture-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(252, 209, 22, 0.9);
            color: #000;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 1000;
            display: none;
        }

        .capture-indicator.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 900px) {
            .main-container { grid-template-columns: 1fr; }
            .sidebar { max-height: 45vh; }
            .cursor-coords-bar { left: 10px; right: 10px; bottom: 60px; }
        }

        /* ==================== BASEMAP SWITCHER STYLES ==================== */
        .basemap-switcher {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05));
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .basemap-options {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .basemap-option {
            padding: 10px 8px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 0.7rem;
            border: 2px solid rgba(59, 130, 246, 0.2);
            transition: all 0.3s ease;
            background: rgba(59, 130, 246, 0.05);
            color: var(--text-light);
        }

        .basemap-option:hover {
            background: rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.5);
            transform: translateY(-2px);
        }

        .basemap-option.active {
            background: rgba(59, 130, 246, 0.25);
            border-color: #3b82f6;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
        }

        .basemap-icon {
            font-size: 1.5rem;
            display: block;
            margin-bottom: 6px;
        }

        /* ==================== ROUTE TYPE SELECTOR STYLES ==================== */
        .route-type-selector-panel {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(16, 185, 129, 0.05));
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .route-type-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .route-type-btn {
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-size: 0.75rem;
            border: 2px solid rgba(16, 185, 129, 0.2);
            transition: all 0.3s ease;
            background: rgba(16, 185, 129, 0.05);
            color: var(--text-light);
        }

        .route-type-btn:hover {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.5);
            transform: translateY(-2px);
        }

        .route-type-btn.active {
            background: rgba(16, 185, 129, 0.25);
            border-color: #10b981;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
        }

        .route-type-btn.river {
            border-color: rgba(14, 165, 233, 0.2);
            background: rgba(14, 165, 233, 0.05);
        }

        .route-type-btn.river:hover {
            background: rgba(14, 165, 233, 0.15);
            border-color: rgba(14, 165, 233, 0.5);
        }

        .route-type-btn.river.active {
            background: rgba(14, 165, 233, 0.25);
            border-color: #0ea5e9;
            box-shadow: 0 0 15px rgba(14, 165, 233, 0.3);
        }

        .route-type-icon {
            font-size: 2rem;
            display: block;
            margin-bottom: 6px;
        }

        /* ==================== RIVER ROUTE STYLES ==================== */
        .route-item.river {
            border-left: 4px solid #0ea5e9;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.08), rgba(14, 165, 233, 0.02));
        }

        .route-item.river:hover {
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.15), rgba(14, 165, 233, 0.05));
        }

        .route-mode-tag.river {
            background: rgba(14, 165, 233, 0.15);
            border-color: #0ea5e9;
            color: #7dd3fc;
        }
        
        /* ==================== EDITING INDICATOR ==================== */
        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            }
            50% {
                box-shadow: 0 4px 20px rgba(14, 165, 233, 0.6);
            }
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        #editingIndicator {
            animation: slideDown 0.3s ease, pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="header"></div>

    <div class="header-content">
        <div class="logo-section">
            <h1>
                üöå Sistema de calculo de Rutas de Transporte Escolar - MINEDEC
                <img src="logo.png" alt="Ecuador" class="logo-img">
            </h1>
            <span>DPI-CGPGE</span>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-secondary" onclick="centerMap()">üìç Centrar</button>
            <button class="btn btn-secondary" onclick="toggleDebug()">üîß Debug</button>
            <button class="btn btn-primary" onclick="exportToJPG()">üì∑ JPG</button>
            <button class="btn btn-success" onclick="exportToPDF()">üìÑ PDF</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <!-- ==================== BASEMAP SWITCHER ==================== -->
            <div class="basemap-switcher">
                <div class="section-title">üó∫Ô∏è Mapa Base</div>
                <div class="basemap-options">
                    <div class="basemap-option active" onclick="changeBasemap('osm')" id="basemap-osm">
                        <span class="basemap-icon">üó∫Ô∏è</span>
                        <span>Normal</span>
                    </div>
                    <div class="basemap-option" onclick="changeBasemap('satellite')" id="basemap-satellite">
                        <span class="basemap-icon">üõ∞Ô∏è</span>
                        <span>Sat√©lite</span>
                    </div>
                    <div class="basemap-option" onclick="changeBasemap('hybrid')" id="basemap-hybrid">
                        <span class="basemap-icon">üåç</span>
                        <span>H√≠brido</span>
                    </div>
                </div>
            </div>

            <!-- ==================== ROUTE TYPE SELECTOR ==================== -->
            <div class="route-type-selector-panel">
                <div class="section-title">üö¶ Tipo de Ruta</div>
                <div class="route-type-selector">
                    <div class="route-type-btn" onclick="selectRouteType('terrestrial')" id="type-terrestrial">
                        <span class="route-type-icon">üöå</span>
                        <span>Terrestre</span>
                    </div>
                    <div class="route-type-btn river" onclick="selectRouteType('river')" id="type-river">
                        <span class="route-type-icon">üö§</span>
                        <span>Fluvial</span>
                    </div>
                </div>
            </div>

            <!-- ==================== LAT LON TOOLS PANEL ==================== -->
            <div class="latlon-tools-panel">
                <div class="section-title">üåê Lat Lon Tools</div>
                
                <div class="latlon-tools-tabs">
                    <button class="latlon-tab active" onclick="switchLatLonTab('capture')">üìç Capturar</button>
                    <button class="latlon-tab" onclick="switchLatLonTab('convert')">üîÑ Convertir</button>
                    <button class="latlon-tab" onclick="switchLatLonTab('zoom')">üîç Zoom</button>
                </div>

                <!-- Tab: Capture Coordinates -->
                <div id="latlon-capture" class="latlon-content active">
                    <div class="coord-display" id="capturedCoords">
                        <div class="coord-display-row">
                            <span class="coord-label">Lat, Lon (DD):</span>
                            <span class="coord-value" id="coord-dd" onclick="copyCoord('dd')" title="Clic para copiar">--.------, --.------</span>
                        </div>
                        <div class="coord-display-row">
                            <span class="coord-label">DMS:</span>
                            <span class="coord-value" id="coord-dms" onclick="copyCoord('dms')" title="Clic para copiar">--¬∞ --' --" N, --¬∞ --' --" W</span>
                        </div>
                        <div class="coord-display-row">
                            <span class="coord-label">UTM 17S:</span>
                            <span class="coord-value" id="coord-utm" onclick="copyCoord('utm')" title="Clic para copiar">-------, -------</span>
                        </div>
                    </div>
                    <div class="latlon-btn-group">
                        <button class="latlon-btn latlon-btn-primary" id="captureBtn" onclick="toggleCaptureMode()">
                            üìç Activar Captura
                        </button>
                        <button class="latlon-btn latlon-btn-success" onclick="copyAllCoords()">
                            üìã Copiar Todo
                        </button>
                    </div>
                </div>

                <!-- Tab: Coordinate Converter -->
                <div id="latlon-convert" class="latlon-content">
                    <select class="format-select" id="inputFormat" onchange="updateConverterPlaceholder()">
                        <option value="dd">Decimal Degrees (lat, lon)</option>
                        <option value="dms">DMS (¬∞ ' ")</option>
                        <option value="utm">UTM (X, Y)</option>
                    </select>
                    <input type="text" class="converter-input" id="converterInput" 
                           placeholder="Ej: -0.1807, -78.4678" 
                           onkeyup="convertCoordinates()">
                    <div class="converter-results" id="converterResults">
                        <div class="result-item">
                            <span class="result-label">Decimal:</span>
                            <span class="result-value" id="result-dd" onclick="copyResult('dd')">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">DMS:</span>
                            <span class="result-value" id="result-dms" onclick="copyResult('dms')">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">UTM 17S:</span>
                            <span class="result-value" id="result-utm" onclick="copyResult('utm')">--</span>
                        </div>
                    </div>
                    <div class="latlon-btn-group">
                        <button class="latlon-btn latlon-btn-primary" onclick="zoomToConverted()">
                            üîç Ir al Mapa
                        </button>
                    </div>
                </div>

                <!-- Tab: Zoom to Coordinates -->
                <div id="latlon-zoom" class="latlon-content">
                    <select class="format-select" id="zoomFormat">
                        <option value="dd">Decimal Degrees (lat, lon)</option>
                        <option value="dms">DMS (¬∞ ' ")</option>
                        <option value="utm">UTM (X, Y)</option>
                    </select>
                    <input type="text" class="converter-input" id="zoomInput" 
                           placeholder="Ingrese coordenadas..."
                           onkeydown="if(event.key==='Enter') zoomToCoordinate()">
                    <div class="latlon-btn-group">
                        <button class="latlon-btn latlon-btn-primary" onclick="zoomToCoordinate()">
                            üîç Zoom a Coordenada
                        </button>
                        <button class="latlon-btn latlon-btn-success" onclick="clearZoomMarker()">
                            üóëÔ∏è Limpiar Marcador
                        </button>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üìÅ Cargar Excel (Hoja RUTA)</div>
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept=".xlsx,.xlsm,.xls">
                    <div class="upload-icon">üìä</div>
                    <div class="upload-text">
                        <strong>Arrastra</strong> tu archivo Excel<br>
                        o <strong>haz clic</strong> para seleccionar
                    </div>
                </div>
                <div class="debug-panel" id="debugPanel"></div>
            </div>

            <div class="section" id="ieInfoSection" style="display:none;">
                <div class="ie-info">
                    <h3>üè´ IE Eje (Destino)</h3>
                    <p id="ieNombre">-</p>
                    <p id="ieAmie">AMIE: -</p>
                    <p id="ieDistrito">Distrito: -</p>
                    <p class="coords" id="ieCoords">Coordenadas: -</p>
                </div>
            </div>

            <div class="section">
                <div class="section-title">‚ûï Agregar Ruta Manual</div>
                <button class="btn btn-primary btn-block" onclick="openModal()">
                    üó∫Ô∏è Nueva Ruta
                </button>
            </div>

            <div class="section">
                <div class="section-title">
                    üìã Rutas (<span id="routeCount">0</span>)
                </div>
                <div class="route-list" id="routeList">
                    <div style="text-align:center; padding:25px; color:var(--text-muted);">
                        <div style="font-size:2rem; margin-bottom:8px;">üõ£Ô∏è</div>
                        <div>No hay rutas cargadas</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üìä Estad√≠sticas</div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalRoutes">0</div>
                        <div class="stat-label">Rutas</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalStudents">0</div>
                        <div class="stat-label">Estudiantes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalDistance">0</div>
                        <div class="stat-label">Km Total</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalIE">0</div>
                        <div class="stat-label">IE Origen</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <button class="btn btn-danger btn-block" onclick="clearAll()">
                    üóëÔ∏è Limpiar Todo
                </button>
            </div>
        </div>

        <div id="map"></div>
        
        <!-- Capture Mode Indicator -->
        <div class="capture-indicator" id="captureIndicator">üìç Modo Captura - Clic en el mapa</div>
    </div>

    <!-- Cursor Coordinates Bar -->
    <div class="cursor-coords-bar" id="cursorCoordsBar">
        <div class="cursor-coord-item">
            <span class="cursor-coord-label">DD:</span>
            <span class="cursor-coord-value" id="cursor-dd">--.------, --.------</span>
        </div>
        <div class="cursor-coord-item">
            <span class="cursor-coord-label">UTM:</span>
            <span class="cursor-coord-value" id="cursor-utm">-------, -------</span>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal" id="draggableModal" style="max-width: 650px;">
            <div class="drag-handle-indicator">Arrastra para mover</div>
            <div class="modal-header" id="modalHeader">
                <h2 class="modal-title">üó∫Ô∏è Nueva Ruta Manual</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>

            <form id="routeForm" onsubmit="saveManualRoute(event)">
                <!-- Informaci√≥n B√°sica -->
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">N√∫mero de Ruta *</label>
                        <input type="text" class="form-input" id="routeNumber" required placeholder="Ej: 1, 2, 3...">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Beneficiarios *</label>
                        <input type="number" class="form-input" id="routeBeneficiaries" required min="1" placeholder="Ej: 25">
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">C√≥digo AMIE Fusionada/Comunidad</label>
                    <input type="text" class="form-input" id="originAmie" placeholder="Opcional: 07H00123">
                </div>

                <!-- Sistema de Puntos -->
                <div class="point-system-section">
                    <div class="point-system-title">üìç Sistema de Dibujo por Puntos</div>
                    
                    <div class="current-coord-panel">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Coordenada X (UTM)</label>
                                <input type="text" class="form-input" id="currentX" placeholder="Ej: 785432">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Coordenada Y (UTM)</label>
                                <input type="text" class="form-input" id="currentY" placeholder="Ej: 9876543">
                            </div>
                        </div>
                        
                        <div class="point-actions">
                            <button type="button" class="btn btn-secondary" onclick="goToPoint()" style="flex: 1;">
                                üîç Ir a Punto
                            </button>
                            <button type="button" class="btn btn-primary" onclick="fixPoint()" style="flex: 1;">
                                üìç Fijar Punto
                            </button>
                        </div>
                    </div>

                    <!-- Lista de Puntos Fijados -->
                    <div class="fixed-points-panel" id="fixedPointsPanel" style="display: none;">
                        <div class="fixed-points-header">
                            <span style="font-weight: 600; color: var(--success);">Puntos Fijados: <span id="pointCount">0</span></span>
                            <span style="font-size: 0.85rem; color: var(--text-muted);">Distancia: <span id="routeDistanceCalc">0.00</span> km</span>
                        </div>
                        <div class="fixed-points-list" id="fixedPointsList"></div>
                    </div>

                    <!-- Herramientas de Edici√≥n -->
                    <div class="drawing-tools">
                        <button type="button" class="btn btn-secondary btn-sm" onclick="toggleEditVertices()" id="editVerticesBtn" disabled>
                            ‚úèÔ∏è Editar V√©rtices
                        </button>
                        <button type="button" class="btn btn-secondary btn-sm" onclick="undoLastPoint()" id="undoBtn" disabled>
                            ‚Ü©Ô∏è Deshacer
                        </button>
                        <button type="button" class="btn btn-danger btn-sm" onclick="clearAllPoints()" id="clearBtn" disabled>
                            üóëÔ∏è Limpiar
                        </button>
                    </div>
                </div>

                <!-- Informaci√≥n Adicional -->
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Tipo de Ruta</label>
                        <select class="form-input" id="routeType">
                            <option value="terrestrial">üöå Terrestre</option>
                            <option value="river">üö§ Fluvial</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Transporte</label>
                        <select class="form-input" id="routeTransport">
                            <option value="BUS">Bus</option>
                            <option value="FURGONETA">Furgoneta</option>
                            <option value="CANOA">Canoa/Fluvial</option>
                        </select>
                    </div>
                </div>

                <!-- Botones de Acci√≥n -->
                <div class="batch-actions" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                    <button class="btn btn-primary btn-block" type="button" onclick="addRouteToBatch()" id="addRouteBatchBtn" disabled>
                        ‚ûï Agregar Ruta
                    </button>
                    <button class="btn btn-success btn-block" type="button" onclick="saveAllRoutes()" id="saveAllRoutesBtn" disabled>
                        üíæ Guardar Todo (<span id="batchCount">0</span>)
                    </button>
                </div>

                <!-- Lista de Rutas en Batch -->
                <div class="batch-routes-panel" id="batchRoutesPanel" style="display: none;">
                    <div class="batch-header">
                        <span style="font-weight: 600; color: var(--yellow);">Rutas Agregadas: <span id="batchRouteCount">0</span>/20</span>
                        <button class="btn btn-danger btn-sm" onclick="clearBatch()" style="padding: 4px 10px; font-size: 0.7rem;">
                            üóëÔ∏è Limpiar Batch
                        </button>
                    </div>
                    <div class="batch-routes-list" id="batchRoutesList"></div>
                </div>
            </form>
        </div>
    </div>

    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Procesando...</div>
    </div>

    <div class="notification" id="notification"></div>

    <div class="drawing-toolbar" id="drawingToolbar">
        <span id="drawingStatus">‚úèÔ∏è Dibujando</span>
        <span class="hint">Clic para agregar puntos</span>
        <button class="btn btn-secondary btn-sm" onclick="undoLastPoint()">‚Ü© Deshacer</button>
        <button class="btn btn-primary btn-sm" onclick="finishDrawing()">‚úÖ Finalizar</button>
        <button class="btn btn-danger btn-sm" onclick="cancelDrawing()">‚úï Cancelar</button>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>

    <script>
        // ==================== CONFIG ====================
        const CONFIG = {
            UTM_ZONE: 17,
            SOUTHERN_HEMISPHERE: false,
            DEFAULT_CENTER: [0.1, -79.2],
            DEFAULT_ZOOM: 10,
            OSRM_URL: 'https://router.project-osrm.org/route/v1/driving'
        };

        // ==================== VARIABLES ====================
        let map, routes = [], markers = [], polylines = [], ieEje = null;
        let drawingMode = false, drawingRouteId = null, drawingPolyline = null, drawingPoints = [];
        
        // Colores en tonos de ROJO para las rutas
        const routeColors = ['#ff0000', '#dc2626', '#b91c1c', '#991b1b', '#7f1d1d', '#ef4444', '#f87171', '#fca5a5', '#c81e1e', '#e53935'];

        // ==================== BASEMAP & ROUTE TYPE VARIABLES ====================
        let basemapLayers = {};
        let currentBasemap = 'osm';
        let currentRouteType = null; // null = mostrar todos, 'terrestrial' o 'river' para filtrar
        const RIVER_COLOR = '#0ea5e9'; // Color azul para rutas fluviales

        // ==================== LAT LON TOOLS VARIABLES ====================
        let captureMode = false;
        let lastCapturedCoords = null;
        let lastConvertedCoords = null;
        let zoomMarker = null;

        // ==================== MANUAL DRAWING SYSTEM VARIABLES ====================
        let fixedPoints = []; // Array de puntos fijados { lat, lon, x, y, marker, label }
        let previewMarker = null; // Marcador temporal de vista previa
        let manualPolyline = null; // L√≠nea que conecta los puntos
        let editMode = false; // Modo de edici√≥n de v√©rtices
        let isDraggingPoint = false; // Flag para saber si se est√° arrastrando un punto

        // ==================== BATCH ROUTES SYSTEM VARIABLES ====================
        let batchRoutes = []; // Array de rutas agregadas al batch (m√°x 20)
        const MAX_BATCH_ROUTES = 20; // L√≠mite m√°ximo de rutas por batch

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            initFileUpload();
            initLatLonTools();
            log('Sistema listo - Lat Lon Tools integrado');
        });

        function initMap() {
            map = L.map('map').setView(CONFIG.DEFAULT_CENTER, CONFIG.DEFAULT_ZOOM);
            
            // Crear las 3 capas de basemap
            basemapLayers.osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap | MINEDUC',
                maxZoom: 19
            });
            
            basemapLayers.satellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                attribution: '¬© Google',
                maxZoom: 20
            });
            
            basemapLayers.hybrid = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                attribution: '¬© Google',
                maxZoom: 20
            });
            
            // Agregar capa inicial (OSM)
            basemapLayers.osm.addTo(map);
        }

        function initFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            uploadArea.onclick = () => fileInput.click();
            uploadArea.ondragover = (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); };
            uploadArea.ondragleave = () => uploadArea.classList.remove('dragover');
            uploadArea.ondrop = (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                if (e.dataTransfer.files[0]) processFile(e.dataTransfer.files[0]);
            };
            fileInput.onchange = (e) => { if (e.target.files[0]) processFile(e.target.files[0]); };
        }

        // ==================== BASEMAP & ROUTE TYPE FUNCTIONS ====================
        function changeBasemap(type) {
            // Remover capa actual
            if (basemapLayers[currentBasemap]) {
                map.removeLayer(basemapLayers[currentBasemap]);
            }

            // Agregar nueva capa
            if (basemapLayers[type]) {
                basemapLayers[type].addTo(map);
                currentBasemap = type;
            }

            // Actualizar UI
            document.querySelectorAll('.basemap-option').forEach(el => el.classList.remove('active'));
            document.getElementById('basemap-' + type).classList.add('active');

            const names = { osm: 'Normal', satellite: 'Sat√©lite', hybrid: 'H√≠brido' };
            showNotification(`üó∫Ô∏è Mapa cambiado a ${names[type]}`, 'success');
        }

        function selectRouteType(type) {
            const btn = document.getElementById('type-' + type);
            const isCurrentlyActive = btn.classList.contains('active');
            
            if (isCurrentlyActive) {
                // Si ya est√° activo, desactivarlo
                btn.classList.remove('active');
                currentRouteType = null;
                showNotification('üîÑ Mostrando todos los tipos de ruta', 'info');
            } else {
                // Desactivar todos primero
                document.querySelectorAll('.route-type-btn').forEach(el => el.classList.remove('active'));
                // Activar el seleccionado
                btn.classList.add('active');
                currentRouteType = type;
                
                const icon = type === 'terrestrial' ? 'üöå' : 'üö§';
                const name = type === 'terrestrial' ? 'Terrestre' : 'Fluvial';
                showNotification(`${icon} Modo ${name} activado`, 'info');
            }
            
            // Redibujar el mapa con el filtro activo
            redrawAll();
        }

        // ==================== LAT LON TOOLS FUNCTIONS ====================
        function initLatLonTools() {
            map.on('mousemove', updateCursorCoords);
            map.on('click', onMapClick);
        }

        function switchLatLonTab(tabId) {
            document.querySelectorAll('.latlon-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.latlon-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`latlon-${tabId}`).classList.add('active');
        }

        function updateCursorCoords(e) {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            document.getElementById('cursor-dd').textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
            const utm = latLonToUtm(lat, lon);
            document.getElementById('cursor-utm').textContent = `${utm.x.toFixed(0)}, ${utm.y.toFixed(0)}`;
        }

        function toggleCaptureMode() {
            captureMode = !captureMode;
            const btn = document.getElementById('captureBtn');
            const indicator = document.getElementById('captureIndicator');
            const panel = document.querySelector('.latlon-tools-panel');
            
            if (captureMode) {
                btn.textContent = 'üî¥ Desactivar Captura';
                btn.style.background = 'rgba(239, 68, 68, 0.3)';
                btn.style.borderColor = '#ef4444';
                indicator.classList.add('show');
                panel.classList.add('capture-mode-active');
                map.getContainer().style.cursor = 'crosshair';
            } else {
                btn.textContent = 'üìç Activar Captura';
                btn.style.background = '';
                btn.style.borderColor = '';
                indicator.classList.remove('show');
                panel.classList.remove('capture-mode-active');
                map.getContainer().style.cursor = '';
            }
        }

        function onMapClick(e) {
            if (!captureMode) return;
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            lastCapturedCoords = { lat, lon };
            document.getElementById('coord-dd').textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
            const dms = latLonToDMS(lat, lon);
            document.getElementById('coord-dms').textContent = dms;
            const utm = latLonToUtm(lat, lon);
            document.getElementById('coord-utm').textContent = `${utm.x.toFixed(2)}, ${utm.y.toFixed(2)}`;
            showNotification('üìç Coordenadas capturadas', 'success');
        }

        function copyCoord(format) {
            if (!lastCapturedCoords) {
                showNotification('‚ö†Ô∏è Primero captura una coordenada', 'error');
                return;
            }
            let text = '';
            const { lat, lon } = lastCapturedCoords;
            switch (format) {
                case 'dd': text = `${lat.toFixed(6)}, ${lon.toFixed(6)}`; break;
                case 'dms': text = latLonToDMS(lat, lon); break;
                case 'utm': const utm = latLonToUtm(lat, lon); text = `${utm.x.toFixed(2)}, ${utm.y.toFixed(2)}`; break;
            }
            navigator.clipboard.writeText(text);
            showNotification('üìã Copiado: ' + text, 'success');
        }

        function copyAllCoords() {
            if (!lastCapturedCoords) {
                showNotification('‚ö†Ô∏è Primero captura una coordenada', 'error');
                return;
            }
            const { lat, lon } = lastCapturedCoords;
            const utm = latLonToUtm(lat, lon);
            const dms = latLonToDMS(lat, lon);
            const text = `DD: ${lat.toFixed(6)}, ${lon.toFixed(6)}\nDMS: ${dms}\nUTM: ${utm.x.toFixed(2)}, ${utm.y.toFixed(2)}`;
            navigator.clipboard.writeText(text);
            showNotification('üìã Todas las coordenadas copiadas', 'success');
        }

        function updateConverterPlaceholder() {
            const format = document.getElementById('inputFormat').value;
            const input = document.getElementById('converterInput');
            switch (format) {
                case 'dd': input.placeholder = 'Ej: -0.1807, -78.4678'; break;
                case 'dms': input.placeholder = "Ej: 0¬∞10'50\"S, 78¬∞28'4\"W"; break;
                case 'utm': input.placeholder = 'Ej: 772000, 9980000'; break;
            }
        }

        function convertCoordinates() {
            const format = document.getElementById('inputFormat').value;
            const input = document.getElementById('converterInput').value.trim();
            if (!input) { clearConverterResults(); return; }
            try {
                let lat, lon;
                switch (format) {
                    case 'dd':
                        const ddParts = input.split(/[,\s]+/).filter(p => p);
                        lat = parseFloat(ddParts[0]); lon = parseFloat(ddParts[1]); break;
                    case 'dms':
                        const coords = parseDMS(input); lat = coords.lat; lon = coords.lon; break;
                    case 'utm':
                        const utmParts = input.split(/[,\s]+/).filter(p => p);
                        const x = parseFloat(utmParts[0]); const y = parseFloat(utmParts[1]);
                        const ll = utmToLatLon(x, y); lat = ll.lat; lon = ll.lon; break;
                }
                if (isNaN(lat) || isNaN(lon)) throw new Error('Invalid');
                lastConvertedCoords = { lat, lon };
                document.getElementById('result-dd').textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                document.getElementById('result-dms').textContent = latLonToDMS(lat, lon);
                const utm = latLonToUtm(lat, lon);
                document.getElementById('result-utm').textContent = `${utm.x.toFixed(2)}, ${utm.y.toFixed(2)}`;
            } catch (e) { clearConverterResults(); }
        }

        function clearConverterResults() {
            document.getElementById('result-dd').textContent = '--';
            document.getElementById('result-dms').textContent = '--';
            document.getElementById('result-utm').textContent = '--';
            lastConvertedCoords = null;
        }

        function copyResult(format) {
            if (!lastConvertedCoords) return;
            let text = '';
            const { lat, lon } = lastConvertedCoords;
            switch (format) {
                case 'dd': text = `${lat.toFixed(6)}, ${lon.toFixed(6)}`; break;
                case 'dms': text = latLonToDMS(lat, lon); break;
                case 'utm': const utm = latLonToUtm(lat, lon); text = `${utm.x.toFixed(2)}, ${utm.y.toFixed(2)}`; break;
            }
            navigator.clipboard.writeText(text);
            showNotification('üìã Copiado: ' + text, 'success');
        }

        function zoomToConverted() {
            if (!lastConvertedCoords) { showNotification('‚ö†Ô∏è Primero convierte una coordenada', 'error'); return; }
            const { lat, lon } = lastConvertedCoords;
            zoomToPoint(lat, lon);
        }

        function zoomToCoordinate() {
            const format = document.getElementById('zoomFormat').value;
            const input = document.getElementById('zoomInput').value.trim();
            if (!input) { showNotification('‚ö†Ô∏è Ingresa una coordenada', 'error'); return; }
            try {
                let lat, lon;
                switch (format) {
                    case 'dd':
                        const ddParts = input.split(/[,\s]+/).filter(p => p);
                        lat = parseFloat(ddParts[0]); lon = parseFloat(ddParts[1]); break;
                    case 'dms':
                        const coords = parseDMS(input); lat = coords.lat; lon = coords.lon; break;
                    case 'utm':
                        const utmParts = input.split(/[,\s]+/).filter(p => p);
                        const x = parseFloat(utmParts[0]); const y = parseFloat(utmParts[1]);
                        const ll = utmToLatLon(x, y); lat = ll.lat; lon = ll.lon; break;
                }
                if (isNaN(lat) || isNaN(lon)) throw new Error('Invalid');
                zoomToPoint(lat, lon);
            } catch (e) { showNotification('‚ùå Formato de coordenada inv√°lido', 'error'); }
        }

        function zoomToPoint(lat, lon) {
            if (zoomMarker) map.removeLayer(zoomMarker);
            const icon = L.divIcon({ className: 'zoom-marker', iconSize: [20, 20], iconAnchor: [10, 10] });
            zoomMarker = L.marker([lat, lon], { icon })
                .addTo(map)
                .bindPopup(`<b style="color:#fcd116">üìç Posici√≥n</b><br><small>Lat: ${lat.toFixed(6)}</small><br><small>Lon: ${lon.toFixed(6)}</small>`)
                .openPopup();
            map.setView([lat, lon], 15);
            showNotification('üîç Zoom a coordenada', 'success');
        }

        function clearZoomMarker() {
            if (zoomMarker) { map.removeLayer(zoomMarker); zoomMarker = null; showNotification('üóëÔ∏è Marcador eliminado', 'info'); }
        }

        // ==================== COORDINATE CONVERSION FUNCTIONS ====================
        function latLonToDMS(lat, lon) {
            const latDir = lat >= 0 ? 'N' : 'S';
            const lonDir = lon >= 0 ? 'E' : 'W';
            const latAbs = Math.abs(lat);
            const lonAbs = Math.abs(lon);
            const latDeg = Math.floor(latAbs);
            const latMin = Math.floor((latAbs - latDeg) * 60);
            const latSec = ((latAbs - latDeg) * 60 - latMin) * 60;
            const lonDeg = Math.floor(lonAbs);
            const lonMin = Math.floor((lonAbs - lonDeg) * 60);
            const lonSec = ((lonAbs - lonDeg) * 60 - lonMin) * 60;
            return `${latDeg}¬∞ ${latMin}' ${latSec.toFixed(2)}" ${latDir}, ${lonDeg}¬∞ ${lonMin}' ${lonSec.toFixed(2)}" ${lonDir}`;
        }

        function parseDMS(dmsStr) {
            const pattern = /(\d+)[¬∞\s]+(\d+)['\s]+(\d+\.?\d*)["\s]*([NSns])?[,\s]+(\d+)[¬∞\s]+(\d+)['\s]+(\d+\.?\d*)["\s]*([EWew])?/i;
            const match = dmsStr.match(pattern);
            if (!match) {
                const simplePattern = /(\d+\.?\d*)[,\s]+(\d+\.?\d*)/;
                const simpleMatch = dmsStr.match(simplePattern);
                if (simpleMatch) return { lat: parseFloat(simpleMatch[1]), lon: parseFloat(simpleMatch[2]) };
                throw new Error('Cannot parse DMS');
            }
            let lat = parseInt(match[1]) + parseInt(match[2]) / 60 + parseFloat(match[3]) / 3600;
            let lon = parseInt(match[5]) + parseInt(match[6]) / 60 + parseFloat(match[7]) / 3600;
            if (match[4] && match[4].toUpperCase() === 'S') lat = -lat;
            if (match[8] && match[8].toUpperCase() === 'W') lon = -lon;
            return { lat, lon };
        }

        function latLonToUtm(lat, lon) {
            const a = 6378137.0;
            const f = 1 / 298.257223563;
            const k0 = 0.9996;
            const e2 = 2 * f - f * f;
            const e = Math.sqrt(e2);
            const ePrime2 = e2 / (1 - e2);
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;
            const zone = CONFIG.UTM_ZONE;
            const lon0 = ((zone - 1) * 6 - 180 + 3) * Math.PI / 180;
            const N = a / Math.sqrt(1 - e2 * Math.sin(latRad) ** 2);
            const T = Math.tan(latRad) ** 2;
            const C = ePrime2 * Math.cos(latRad) ** 2;
            const A = Math.cos(latRad) * (lonRad - lon0);
            const M = a * (
                (1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256) * latRad -
                (3*e2/8 + 3*e2*e2/32 + 45*e2*e2*e2/1024) * Math.sin(2*latRad) +
                (15*e2*e2/256 + 45*e2*e2*e2/1024) * Math.sin(4*latRad) -
                (35*e2*e2*e2/3072) * Math.sin(6*latRad)
            );
            const x = k0 * N * (A + (1-T+C)*A**3/6 + (5-18*T+T*T+72*C-58*ePrime2)*A**5/120) + 500000;
            const y = k0 * (M + N * Math.tan(latRad) * (A*A/2 + (5-T+9*C+4*C*C)*A**4/24 + (61-58*T+T*T+600*C-330*ePrime2)*A**6/720));
            const yFinal = lat < 0 ? y + 10000000 : y + 10000000;
            return { x, y: yFinal };
        }

        // ==================== DEBUG ====================
        function log(msg) {
            console.log(msg);
            const panel = document.getElementById('debugPanel');
            panel.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}<br>` + panel.innerHTML;
        }

        function toggleDebug() { document.getElementById('debugPanel').classList.toggle('show'); }

        // ==================== UTM ‚Üí LAT/LON ====================
        function utmToLatLon(x, y) {
            const a = 6378137.0;
            const f = 1 / 298.257223563;
            const k0 = 0.9996;
            const e = Math.sqrt(2 * f - f * f);
            const e2 = e * e;
            const ePrime2 = e2 / (1 - e2);
            const xAdj = x - 500000;
            const yAdj = y - 10000000;
            const M = yAdj / k0;
            const mu = M / (a * (1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256));
            const e1 = (1 - Math.sqrt(1 - e2)) / (1 + Math.sqrt(1 - e2));
            const phi1 = mu +
                (3*e1/2 - 27*Math.pow(e1,3)/32) * Math.sin(2*mu) +
                (21*e1*e1/16 - 55*Math.pow(e1,4)/32) * Math.sin(4*mu) +
                (151*Math.pow(e1,3)/96) * Math.sin(6*mu);
            const N1 = a / Math.sqrt(1 - e2 * Math.sin(phi1) ** 2);
            const T1 = Math.tan(phi1) ** 2;
            const C1 = ePrime2 * Math.cos(phi1) ** 2;
            const R1 = a * (1 - e2) / Math.pow(1 - e2 * Math.sin(phi1) ** 2, 1.5);
            const D = xAdj / (N1 * k0);
            let lat = phi1 - (N1 * Math.tan(phi1) / R1) *
                (D*D/2 - (5 + 3*T1 + 10*C1 - 4*C1*C1 - 9*ePrime2) * Math.pow(D,4)/24 +
                (61 + 90*T1 + 298*C1 + 45*T1*T1 - 252*ePrime2 - 3*C1*C1) * Math.pow(D,6)/720);
            const lon0 = ((CONFIG.UTM_ZONE - 1) * 6 - 180 + 3) * Math.PI / 180;
            let lon = lon0 + (D - (1 + 2*T1 + C1) * Math.pow(D,3)/6 +
                (5 - 2*C1 + 28*T1 - 3*C1*C1 + 8*ePrime2 + 24*T1*T1) * Math.pow(D,5)/120) / Math.cos(phi1);
            return { lat: lat * 180 / Math.PI, lon: lon * 180 / Math.PI };
        }

        // ==================== NORMALIZACION NUMERICA ====================
        // Soporta numeros como string con coma decimal (ej. "678303,90") y elimina espacios.
        function toNumber(v) {
            if (v === null || v === undefined) return NaN;
            if (typeof v === 'number') return v;
            if (typeof v === 'string') {
                const s = v.trim().replace(/\s+/g, '').replace(',', '.');
                if (!s) return NaN;
                const n = Number(s);
                return Number.isFinite(n) ? n : NaN;
            }
            const n = Number(v);
            return Number.isFinite(n) ? n : NaN;
        }

        function hasValidXY(obj) {
            if (!obj) return false;
            const x = toNumber(obj.x);
            const y = toNumber(obj.y);
            return Number.isFinite(x) && Number.isFinite(y);
        }

        // ==================== EXCEL PROCESSING ====================
        async function processFile(file) {
            showLoading(true, 'Leyendo Excel...');
            try {
                log('Archivo: ' + file.name);
                const data = await readExcel(file);
                
                // Validar formato del Excel
                const validationResult = validateExcelFormat(data);
                if (!validationResult.isValid) {
                    throw new Error(validationResult.message);
                }
                
                parseData(data);
                showNotification('‚úÖ Archivo cargado correctamente', 'success');
            } catch (err) {
                log('ERROR: ' + err.message);
                showFormatError(err.message);
            } finally { showLoading(false); }
        }

        function readExcel(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                        
                        // Validaci√≥n 1: Verificar si existe hoja RUTA
                        const hasRutaSheet = wb.SheetNames.some(n => n.toUpperCase() === 'RUTA');
                        if (!hasRutaSheet) {
                            reject(new Error('FORMATO_NO_RECONOCIDO'));
                            return;
                        }
                        
                        const sheetName = wb.SheetNames.find(n => n.toUpperCase() === 'RUTA');
                        log('Usando hoja: ' + sheetName);
                        const sheet = wb.Sheets[sheetName];
                        
                        if (!sheet) {
                            reject(new Error('FORMATO_NO_RECONOCIDO'));
                            return;
                        }
                        
                        resolve(XLSX.utils.sheet_to_json(sheet, { header: 1 }));
                    } catch (err) { 
                        reject(new Error('FORMATO_NO_RECONOCIDO')); 
                    }
                };
                reader.onerror = () => reject(new Error('Error leyendo archivo'));
                reader.readAsArrayBuffer(file);
            });
        }
        
        // ==================== VALIDACI√ìN DE FORMATO ====================
        function validateExcelFormat(data) {
            // Validar que hay datos
            if (!data || data.length < 5) {
                return {
                    isValid: false,
                    message: 'FORMATO_NO_RECONOCIDO'
                };
            }
            
            // Buscar fila de encabezados
            let hasRequiredColumns = false;
            for (let i = 0; i < Math.min(20, data.length); i++) {
                const row = data[i];
                if (!row) continue;
                
                const rowStr = row.join('|').toUpperCase();
                
                // Verificar columnas requeridas
                const hasRuta = rowStr.includes('RUTA');
                const hasCoordenadas = rowStr.includes('COORDENADA X') || rowStr.includes('COORDENADAS X');
                const hasBeneficiarios = rowStr.includes('BENEFICIARIOS');
                
                if (hasRuta && hasCoordenadas && hasBeneficiarios) {
                    hasRequiredColumns = true;
                    break;
                }
            }
            
            if (!hasRequiredColumns) {
                return {
                    isValid: false,
                    message: 'FORMATO_NO_RECONOCIDO'
                };
            }
            
            return {
                isValid: true,
                message: 'Formato v√°lido'
            };
        }
        
        // ==================== VALIDACI√ìN DE COORDENADAS ====================
        function validateCoordinates(x, y, routeNumber) {
            const errors = [];
            
            // Rangos v√°lidos para Ecuador en UTM Zona 17S
            const ECUADOR_X_MIN = 100000;
            const ECUADOR_X_MAX = 1200000;
            const ECUADOR_Y_MIN = 9500000;
            const ECUADOR_Y_MAX = 10500000;
            
            // Validar que sean n√∫meros
            if (isNaN(x) || isNaN(y)) {
                errors.push(`Ruta ${routeNumber}: Coordenadas no son n√∫meros v√°lidos`);
                return { isValid: false, errors };
            }
            
            // Validar rango X (Este)
            if (x < ECUADOR_X_MIN || x > ECUADOR_X_MAX) {
                errors.push(`Ruta ${routeNumber}: Coordenada X (${x.toFixed(0)}) fuera del rango v√°lido para Ecuador (${ECUADOR_X_MIN} - ${ECUADOR_X_MAX})`);
            }
            
            // Validar rango Y (Norte)
            if (y < ECUADOR_Y_MIN || y > ECUADOR_Y_MAX) {
                errors.push(`Ruta ${routeNumber}: Coordenada Y (${y.toFixed(0)}) fuera del rango v√°lido para Ecuador (${ECUADOR_Y_MIN} - ${ECUADOR_Y_MAX})`);
            }
            
            return {
                isValid: errors.length === 0,
                errors: errors
            };
        }
        
        // ==================== MOSTRAR ERRORES ====================
        function showFormatError(errorType) {
            let errorMessage = '';
            let errorDetails = '';
            
            if (errorType === 'FORMATO_NO_RECONOCIDO' || errorType.includes('FORMATO_NO_RECONOCIDO')) {
                errorMessage = 'üìã Formato no reconocido para calcular y dibujar rutas';
                errorDetails = `
                    <div style="text-align: left; margin-top: 15px; line-height: 1.6;">
                        <strong>El archivo Excel debe tener:</strong>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>‚úì Una hoja llamada <strong>"RUTA"</strong></li>
                            <li>‚úì Columnas: RUTA, COORDENADA X, COORDENADA Y, BENEFICIARIOS</li>
                            <li>‚úì Estructura del formato oficial MINEDEC</li>
                        </ul>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid #ef4444;">
                            <strong>‚ö†Ô∏è Error:</strong> El archivo cargado no tiene el formato correcto.
                        </div>
                        <div style="margin-top: 10px; font-size: 0.85rem; color: #8ba3c7;">
                            Por favor, use el formato oficial "FORMATO_TRANSPORTE_MACRO" de MINEDEC.
                        </div>
                    </div>
                `;
            } else if (errorType.includes('COORDENADAS_ERRONEAS')) {
                errorMessage = 'üìç Coordenadas err√≥neas detectadas';
                errorDetails = `
                    <div style="text-align: left; margin-top: 15px; line-height: 1.6;">
                        ${errorType.replace('COORDENADAS_ERRONEAS:', '')}
                        <div style="margin-top: 10px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid #ef4444;">
                            <strong>‚ö†Ô∏è Las coordenadas deben estar en formato UTM Zona 17S</strong>
                        </div>
                        <div style="margin-top: 10px; font-size: 0.85rem; color: #8ba3c7;">
                            Rangos v√°lidos para Ecuador:<br>
                            ‚Ä¢ Coordenada X: 100,000 - 1,200,000<br>
                            ‚Ä¢ Coordenada Y: 9,500,000 - 10,500,000
                        </div>
                    </div>
                `;
            } else {
                errorMessage = '‚ùå Error al procesar archivo';
                errorDetails = `<div style="margin-top: 10px; color: #ef4444;">${errorType}</div>`;
            }
            
            // Crear modal de error personalizado
            showErrorModal(errorMessage, errorDetails);
        }
        
        function showErrorModal(title, details) {
            // Crear modal si no existe
            let modal = document.getElementById('errorModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'errorModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 20000;
                    animation: fadeIn 0.3s ease;
                `;
                document.body.appendChild(modal);
            }
            
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, rgba(15, 30, 55, 0.98), rgba(10, 22, 40, 0.98));
                    border: 2px solid #ef4444;
                    border-radius: 15px;
                    padding: 30px;
                    max-width: 550px;
                    width: 90%;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                    color: white;
                    position: relative;
                ">
                    <button onclick="closeErrorModal()" style="
                        position: absolute;
                        top: 15px;
                        right: 15px;
                        background: rgba(239, 68, 68, 0.2);
                        border: 1px solid #ef4444;
                        color: #ef4444;
                        width: 35px;
                        height: 35px;
                        border-radius: 50%;
                        font-size: 20px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s;
                    " onmouseover="this.style.background='#ef4444'; this.style.color='white'" 
                       onmouseout="this.style.background='rgba(239, 68, 68, 0.2)'; this.style.color='#ef4444'">
                        ‚úï
                    </button>
                    
                    <div style="text-align: center; margin-bottom: 20px;">
                        <div style="
                            width: 80px;
                            height: 80px;
                            background: linear-gradient(135deg, #ef4444, #dc2626);
                            border-radius: 50%;
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 40px;
                            margin-bottom: 15px;
                            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
                        ">‚ö†Ô∏è</div>
                        <h2 style="color: #fca5a5; margin: 0; font-size: 1.4rem;">${title}</h2>
                    </div>
                    
                    ${details}
                    
                    <div style="margin-top: 25px; text-align: center;">
                        <button onclick="closeErrorModal()" style="
                            background: linear-gradient(135deg, #ef4444, #dc2626);
                            color: white;
                            border: none;
                            padding: 12px 30px;
                            border-radius: 8px;
                            font-weight: 600;
                            font-size: 1rem;
                            cursor: pointer;
                            transition: all 0.3s;
                            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
                        " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 6px 20px rgba(239, 68, 68, 0.5)'" 
                           onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 15px rgba(239, 68, 68, 0.3)'">
                            Entendido
                        </button>
                    </div>
                </div>
            `;
            
            modal.style.display = 'flex';
        }
        
        function closeErrorModal() {
            const modal = document.getElementById('errorModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function parseData(data) {
            ieEje = { nombre: '', amie: '', distrito: '', x: null, y: null };
            for (let i = 0; i < Math.min(15, data.length); i++) {
                const row = data[i];
                if (!row) continue;
                for (let j = 0; j < row.length; j++) {
                    const cell = String(row[j] || '').toUpperCase().trim();
                    const nextVal = row[j + 1];
                    if (cell.includes('AMIE') && cell.includes('EJE') && !cell.includes('FUSIONADA')) {
                        if (nextVal) ieEje.amie = String(nextVal).trim();
                    }
                    if (cell.includes('NOMBRE') && cell.includes('UNIDAD') && cell.includes('EJE')) {
                        if (nextVal) ieEje.nombre = String(nextVal).trim();
                    }
                    if (cell.includes('NOMBRE DISTRITO')) {
                        if (nextVal) ieEje.distrito = String(nextVal).trim();
                    }
                    if (cell === 'COORDENADA X' || cell === 'COORDENADAS X') {
                        const val = parseFloat(nextVal);
                        // CORREGIDO: Rango extendido para incluir toda la Amazon√≠a ecuatoriana
                        if (!isNaN(val) && val > 100000 && val < 1200000) { 
                            ieEje.x = val; 
                            log('IE Eje X: ' + val); 
                        }
                    }
                    if (cell === 'COORDENADA Y' || cell === 'COORDENADAS Y') {
                        const val = parseFloat(nextVal);
                        // CORREGIDO: Rango para toda la regi√≥n ecuatorial
                        if (!isNaN(val) && val > 9500000 && val < 10500000) { 
                            ieEje.y = val; 
                            log('IE Eje Y: ' + val); 
                        }
                    }
                }
            }
            if (ieEje.amie || ieEje.x) {
                document.getElementById('ieInfoSection').style.display = 'block';
                document.getElementById('ieNombre').textContent = ieEje.nombre || '-';
                document.getElementById('ieAmie').textContent = 'AMIE: ' + (ieEje.amie || '-');
                document.getElementById('ieDistrito').textContent = ieEje.distrito || '-';
                if (ieEje.x && ieEje.y) {
                    const c = utmToLatLon(ieEje.x, ieEje.y);
                    document.getElementById('ieCoords').textContent = 
                        `UTM: ${ieEje.x.toFixed(2)}, ${ieEje.y.toFixed(2)} ‚Üí Lat: ${c.lat.toFixed(5)}, Lon: ${c.lon.toFixed(5)}`;
                    log('IE Eje LatLon: ' + c.lat.toFixed(5) + ', ' + c.lon.toFixed(5));
                }
            }
            let headerRow = -1;
            let colRuta = 0, colAmie = 2, colBenef = 3, colDist = 7, colX = 9, colY = 10;
            for (let i = 0; i < Math.min(20, data.length); i++) {
                const row = data[i];
                if (!row) continue;
                const rowStr = row.join('|').toUpperCase();
                if (rowStr.includes('RUTA') && rowStr.includes('COORDENADA X') && rowStr.includes('BENEFICIARIOS')) {
                    headerRow = i;
                    log('Encabezado en fila ' + (i + 1));
                    row.forEach((cell, idx) => {
                        const c = String(cell || '').toUpperCase().trim();
                        if (c === 'RUTA') colRuta = idx;
                        if (c.includes('AMIE') && (c.includes('FUSIONADA') || c.includes('COMUNIDAD'))) colAmie = idx;
                        if (c.includes('BENEFICIARIOS') && c.includes('RUTA')) colBenef = idx;
                        if (c.includes('DISTANCIA') && c.includes('RUTA')) colDist = idx;
                        if (c === 'COORDENADA X') colX = idx;
                        if (c === 'COORDENADA Y') colY = idx;
                    });
                    log(`Columnas: RUTA=${colRuta}, AMIE=${colAmie}, BENEF=${colBenef}, DIST=${colDist}, X=${colX}, Y=${colY}`);
                    break;
                }
            }
            if (headerRow === -1) { 
                throw new Error('FORMATO_NO_RECONOCIDO'); 
            }
            clearRoutes();
            routes = [];
            
            // Buscar columnas adicionales para detectar tipo de ruta
            let colTransporte = -1, colObservaciones = -1;
            data[headerRow].forEach((cell, idx) => {
                const c = String(cell || '').toUpperCase().trim();
                if (c.includes('TRANSPORTE') && !c.includes('RUTA')) colTransporte = idx;
                if (c.includes('OBSERVA')) colObservaciones = idx;
            });
            log(`Columnas extras: TRANSPORTE=${colTransporte}, OBSERVACIONES=${colObservaciones}`);
            
            // Array para recolectar errores de coordenadas
            const coordinateErrors = [];
            let validRoutesCount = 0;
            let invalidRoutesCount = 0;
            
            for (let i = headerRow + 1; i < data.length; i++) {
                const row = data[i];
                if (!row || !row[colRuta]) continue;
                const rutaNum = parseInt(row[colRuta]);
                if (isNaN(rutaNum)) continue;
                const xOrig = parseFloat(row[colX]);
                const yOrig = parseFloat(row[colY]);
                
                // Validar coordenadas
                const validation = validateCoordinates(xOrig, yOrig, rutaNum);
                if (!validation.isValid) {
                    coordinateErrors.push(...validation.errors);
                    invalidRoutesCount++;
                    log(`‚ö†Ô∏è Ruta ${rutaNum} omitida por coordenadas inv√°lidas: X=${xOrig}, Y=${yOrig}`);
                    continue; // Saltar esta ruta
                }
                
                // Detectar autom√°ticamente si es ruta fluvial
                let detectedType = currentRouteType; // Por defecto usar el seleccionado
                const transporteText = String(row[colTransporte] || '').toUpperCase();
                const observacionesText = String(row[colObservaciones] || '').toUpperCase();
                const combinedText = transporteText + ' ' + observacionesText;
                
                // Palabras clave para rutas fluviales
                const fluvialKeywords = ['FLUVIAL', 'LANCHA', 'CANOA', 'BOTE', 'RIO', 'R√çO', 'EMBARCACION', 'EMBARCACI√ìN', 'MARITIMO', 'MAR√çTIMO'];
                const isFluvial = fluvialKeywords.some(keyword => combinedText.includes(keyword));
                
                if (isFluvial) {
                    detectedType = 'river';
                    log(`Ruta ${rutaNum} detectada como FLUVIAL (texto: "${combinedText.substring(0, 50)}")`);
                }
                
                const route = {
                    id: Date.now() + Math.random(),
                    numero: rutaNum,
                    amieFusionada: String(row[colAmie] || ''),
                    amieEje: ieEje.amie,
                    beneficiarios: parseInt(row[colBenef]) || 0,
                    distancia: parseFloat(row[colDist]) || 0,
                    origen: { x: xOrig, y: yOrig },
                    destino: { x: ieEje.x, y: ieEje.y },
                    routeType: detectedType, // Usar el tipo detectado autom√°ticamente
                    mode: 'pending',
                    manualGeometry: null
                };
                routes.push(route);
                validRoutesCount++;
                log(`Ruta ${rutaNum}: ${route.beneficiarios} estudiantes, ${xOrig.toFixed(0)},${yOrig.toFixed(0)} - Tipo: ${detectedType}`);
            }
            
            // Si hay errores de coordenadas, mostrarlos
            if (coordinateErrors.length > 0) {
                const errorList = coordinateErrors.map(err => `<li style="margin: 5px 0;">${err}</li>`).join('');
                const errorMessage = `
                    <div style="max-height: 300px; overflow-y: auto; margin-top: 10px;">
                        <strong style="color: #fca5a5;">Se encontraron ${invalidRoutesCount} ruta(s) con coordenadas err√≥neas:</strong>
                        <ul style="margin: 10px 0; padding-left: 20px; text-align: left;">
                            ${errorList}
                        </ul>
                        ${validRoutesCount > 0 ? `<div style="margin-top: 15px; padding: 10px; background: rgba(16, 185, 129, 0.1); border-radius: 6px; border-left: 3px solid #10b981;">
                            <strong style="color: #34d399;">‚úì ${validRoutesCount} ruta(s) v√°lida(s) se procesar√°n correctamente</strong>
                        </div>` : ''}
                    </div>
                `;
                
                if (validRoutesCount === 0) {
                    // Si no hay ninguna ruta v√°lida, mostrar error completo
                    throw new Error('COORDENADAS_ERRONEAS:' + errorMessage);
                } else {
                    // Si hay algunas rutas v√°lidas, mostrar advertencia pero continuar
                    showFormatError('COORDENADAS_ERRONEAS:' + errorMessage);
                }
            }
            
            log(`Total: ${validRoutesCount} rutas v√°lidas, ${invalidRoutesCount} rutas omitidas`);
            if (routes.length === 0) { 
                throw new Error('FORMATO_NO_RECONOCIDO'); 
            }
            drawAllRoutes();
        }

        // ==================== DIBUJAR RUTAS ====================
        async function drawAllRoutes() {
            showLoading(true, 'Dibujando rutas...');
            
            // Filtrar rutas seg√∫n el tipo seleccionado
            let routesToDraw = routes;
            if (currentRouteType === 'terrestrial') {
                routesToDraw = routes.filter(r => r.routeType !== 'river');
            } else if (currentRouteType === 'river') {
                routesToDraw = routes.filter(r => r.routeType === 'river');
            }
            // Si currentRouteType es null, dibuja todas las rutas
            
            for (let i = 0; i < routesToDraw.length; i++) {
                showLoading(true, `Ruta ${i + 1} de ${routesToDraw.length}...`);
                await drawRoute(routesToDraw[i]);
                await sleep(200);
            }
            showLoading(false);
            updateUI();
            centerMap();
            const terrestrialCount = routesToDraw.filter(r => r.routeType !== 'river').length;
            const riverCount = routesToDraw.filter(r => r.routeType === 'river').length;
            log(`‚úÖ Total dibujadas: ${routesToDraw.length} rutas (${terrestrialCount} terrestres, ${riverCount} fluviales)`);
            showNotification(`‚úÖ ${routesToDraw.length} rutas dibujadas (${terrestrialCount} üöå + ${riverCount} üö§)`, 'success');
        }

        async function drawRoute(route) {
            const idx = routes.indexOf(route);
            const isRiver = route.routeType === 'river';
            const color = isRiver ? RIVER_COLOR : routeColors[idx % routeColors.length];
            const icon = isRiver ? 'üö§' : 'üöå';
            
            log(`    drawRoute() - Ruta ${route.numero}: isRiver=${isRiver}, color=${color}, icon=${icon}`);
            log(`    Origen UTM: X=${route.origen.x}, Y=${route.origen.y}`);
            
            const originLL = utmToLatLon(route.origen.x, route.origen.y);
            log(`    Origen LatLon: ${originLL.lat.toFixed(5)}, ${originLL.lon.toFixed(5)}`);
            const originIcon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="background:${color};width:26px;height:26px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:bold;border:2px solid #fff;box-shadow:0 2px 6px rgba(0,0,0,0.4);color:#fff;">${route.numero}</div>`,
                iconSize: [26, 26], iconAnchor: [13, 13]
            });
            const originMarker = L.marker([originLL.lat, originLL.lon], { icon: originIcon })
                .bindPopup(`<b style="color:${color}">${icon} Ruta ${route.numero} - Origen</b><br>Tipo: ${isRiver ? 'Fluvial' : 'Terrestre'}<br>AMIE: ${route.amieFusionada || '-'}<br>Estudiantes: ${route.beneficiarios}<br><small>UTM: ${route.origen.x.toFixed(0)}, ${route.origen.y.toFixed(0)}</small>`)
                .addTo(map);
            markers.push(originMarker);
            route._originMarker = originMarker;
            // Normalizar destino para soportar strings con coma decimal y evitar falsos negativos.
            if (hasValidXY(route.destino)) {
                route.destino.x = toNumber(route.destino.x);
                route.destino.y = toNumber(route.destino.y);
                const destLL = utmToLatLon(route.destino.x, route.destino.y);
                const existsDest = markers.some(m => {
                    const p = m.getLatLng();
                    return Math.abs(p.lat - destLL.lat) < 0.0001 && Math.abs(p.lng - destLL.lon) < 0.0001;
                });
                if (!existsDest) {
                    const destIcon = L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background:#10b981;width:34px;height:34px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:18px;border:3px solid #fff;box-shadow:0 2px 8px rgba(0,0,0,0.4);">üè´</div>`,
                        iconSize: [34, 34], iconAnchor: [17, 17]
                    });
                    const destMarker = L.marker([destLL.lat, destLL.lon], { icon: destIcon })
                        .bindPopup(`<b style="color:#10b981">üè´ IE Eje - Destino</b><br>${ieEje.nombre || '-'}<br>AMIE: ${ieEje.amie || '-'}`)
                        .addTo(map);
                    markers.push(destMarker);
                }
                try {
                    // Para rutas fluviales, usar l√≠nea directa en lugar de OSRM
                    if (isRiver) {
                        log(`    Ruta fluvial detectada - saltando OSRM, usando l√≠nea directa`);
                        throw new Error('Ruta fluvial - l√≠nea directa');
                    }
                    
                    const url = `${CONFIG.OSRM_URL}/${originLL.lon},${originLL.lat};${destLL.lon},${destLL.lat}?overview=full&geometries=geojson`;
                    const resp = await fetch(url);
                    const data = await resp.json();
                    if (data.routes && data.routes[0]) {
                        const coords = data.routes[0].geometry.coordinates.map(([lon, lat]) => [lat, lon]);
                        const distKm = (data.routes[0].distance / 1000).toFixed(2);
                        const durMin = Math.round(data.routes[0].duration / 60);
                        const polyline = L.polyline(coords, { 
                            color: color, 
                            weight: 7, 
                            opacity: 0.95,
                            dashArray: isRiver ? '15, 10' : null
                        })
                            .bindPopup(`<b style="color:${color}">${icon} Ruta ${route.numero}</b><br>Tipo: ${isRiver ? 'Fluvial' : 'Terrestre'}<br>Distancia: ${distKm} km<br>Tiempo: ~${durMin} min<br>Estudiantes: ${route.beneficiarios}`)
                            .addTo(map);
                        polylines.push(polyline);
                        route._polyline = polyline;
                        route.distanciaCalculada = parseFloat(distKm);
                        route.mode = 'osrm';
                    } else { throw new Error('Sin ruta'); }
                } catch (err) {
                    log(`    Dibujando l√≠nea (${isRiver ? 'FLUVIAL' : 'terrestrial'}) - ${err.message}`);
                    const destLL = utmToLatLon(route.destino.x, route.destino.y);
                    
                    // Si es ruta fluvial con geometr√≠a manual, usar esos puntos
                    let coords;
                    if (isRiver && route.manualGeometry && route.manualGeometry.length > 0) {
                        coords = route.manualGeometry;
                        log(`    Usando geometr√≠a manual (${coords.length} puntos)`);
                    } else {
                        // L√≠nea directa
                        coords = [[originLL.lat, originLL.lon], [destLL.lat, destLL.lon]];
                        log(`    L√≠nea directa`);
                    }
                    
                    const polyline = L.polyline(coords, {
                        color: color, 
                        weight: isRiver ? 5 : 4, 
                        opacity: isRiver ? 0.8 : 0.6, 
                        dashArray: isRiver ? '15, 10' : '10, 10'
                    }).addTo(map);
                    log(`    ‚úÖ Polyline dibujada - color:${color}, dashArray:${isRiver ? '15, 10' : '10, 10'}`);
                    polylines.push(polyline);
                    route._polyline = polyline;
                    route.mode = route.manualGeometry ? 'manual' : 'line';
                }
            }
        }

        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

        // ==================== UI ====================
        function updateUI() {
            // Filtrar rutas seg√∫n el tipo seleccionado
            let displayedRoutes = routes;
            if (currentRouteType === 'terrestrial') {
                displayedRoutes = routes.filter(r => r.routeType !== 'river');
            } else if (currentRouteType === 'river') {
                displayedRoutes = routes.filter(r => r.routeType === 'river');
            }
            
            document.getElementById('routeCount').textContent = displayedRoutes.length;
            document.getElementById('totalRoutes').textContent = displayedRoutes.length;
            document.getElementById('totalStudents').textContent = displayedRoutes.reduce((s, r) => s + r.beneficiarios, 0);
            document.getElementById('totalDistance').textContent = displayedRoutes.reduce((s, r) => s + (r.distanciaCalculada || r.distancia || 0), 0).toFixed(1);
            document.getElementById('totalIE').textContent = new Set(displayedRoutes.map(r => r.amieFusionada).filter(a => a)).size;
            const list = document.getElementById('routeList');
            if (displayedRoutes.length === 0) {
                list.innerHTML = `<div style="text-align:center; padding:25px; color:var(--text-muted);"><div style="font-size:2rem; margin-bottom:8px;">üõ£Ô∏è</div><div>No hay rutas ${currentRouteType === 'terrestrial' ? 'terrestres' : currentRouteType === 'river' ? 'fluviales' : 'cargadas'}</div></div>`;
                return;
            }
            list.innerHTML = displayedRoutes.map((r, i) => {
                const actualIdx = routes.indexOf(r); // Usar √≠ndice real del array global
                const isRiver = r.routeType === 'river';
                const color = isRiver ? RIVER_COLOR : routeColors[actualIdx % routeColors.length];
                const icon = isRiver ? 'üö§' : 'üöå';
                const modeLabel = r.mode === 'osrm' ? 'OSRM' : r.mode === 'manual' ? 'Manual' : r.mode === 'line' ? 'L√≠nea' : 'Pend.';
                const riverClass = isRiver ? 'river' : '';
                // ‚úèÔ∏è:
                // - Fluvial: habilita edici√≥n manual del trayecto (existente).
                // - Terrestre sin geometr√≠a: habilita trazo euclideano punto a punto.
                const polyMissing = (!r._polyline) || (r._polyline && !map.hasLayer(r._polyline));
                const needsEuclidean = !isRiver && polyMissing && hasValidXY(r.origen) && hasValidXY(r.destino);
                const editBtn = isRiver ?
                    `<button class="route-edit" onclick="event.stopPropagation();editRiverRoute(${actualIdx})" title="Dibujar/editar trayecto fluvial">‚úèÔ∏è</button>` :
                    (needsEuclidean ? `<button class="route-edit" onclick="event.stopPropagation();drawEuclideanLineForRoute(${actualIdx})" title="Trazar l√≠nea euclideana (punto a punto)">‚úèÔ∏è</button>` : '');
                return `<div class="route-item ${riverClass}" onclick="focusRoute(${actualIdx})"><div class="route-header"><span class="route-number" style="color:${color}">${icon} Ruta ${r.numero}</span><div style="display:flex;align-items:center;gap:6px;"><span class="route-mode-tag ${riverClass}">${modeLabel}</span>${editBtn}<button class="route-delete" onclick="event.stopPropagation();deleteRoute(${actualIdx})" title="Eliminar">üóëÔ∏è</button></div></div><div class="route-info"><span>üë• ${r.beneficiarios} estudiantes</span><span>üìè ${(r.distanciaCalculada || r.distancia || 0).toFixed(2)} km</span>${r.amieFusionada ? `<span>üè´ ${r.amieFusionada}</span>` : ''}<span>${isRiver ? 'üö§ Fluvial' : 'üöå Terrestre'}</span></div></div>`;
            }).join('');
        }

        function focusRoute(idx) {
            const route = routes[idx];
            const ll = utmToLatLon(route.origen.x, route.origen.y);
            map.setView([ll.lat, ll.lon], 14);
        }

        function deleteRoute(idx) {
            if (!confirm('¬øEliminar esta ruta?')) return;
            routes.splice(idx, 1);
            redrawAll();
        }

        // ==================== RUTA EUCLIDEANA (PUNTO A PUNTO) ====================
        // Habilita el bot√≥n ‚úèÔ∏è cuando una ruta solo tiene puntos (origen/destino) pero no se dibuj√≥ el trayecto.
        function drawEuclideanLineForRoute(idx) {
            const route = routes[idx];
            if (!route) return;
            if (route.routeType === 'river') {
                showNotification('‚ö†Ô∏è Esta opci√≥n es para rutas terrestres punto a punto', 'warning');
                return;
            }
            if (!hasValidXY(route.destino)) {
                showNotification('‚ö†Ô∏è Esta ruta no tiene destino v√°lido para trazar la l√≠nea', 'error');
                return;
            }

            // Normalizar valores
            route.origen.x = toNumber(route.origen.x);
            route.origen.y = toNumber(route.origen.y);
            route.destino.x = toNumber(route.destino.x);
            route.destino.y = toNumber(route.destino.y);

            const originLL = utmToLatLon(route.origen.x, route.origen.y);
            const destLL = utmToLatLon(route.destino.x, route.destino.y);
            const coords = [[originLL.lat, originLL.lon], [destLL.lat, destLL.lon]];

            // Guardar como geometr√≠a manual m√≠nima (2 puntos) para mantener trazabilidad en exportaciones
            route.manualGeometry = coords;

            // Distancia euclideana (geod√©sica aprox) usando Leaflet
            const distM = map.distance([originLL.lat, originLL.lon], [destLL.lat, destLL.lon]);
            route.distanciaCalculada = distM / 1000;

            // Marcar como l√≠nea (fallback)
            route.mode = 'line';

            log(`‚úèÔ∏è Ruta ${route.numero}: L√≠nea euclideana creada (${route.distanciaCalculada.toFixed(2)} km)`);
            showNotification(`‚úèÔ∏è Ruta ${route.numero}: L√≠nea euclideana creada (${route.distanciaCalculada.toFixed(2)} km)`, 'success');

            // Redibujar para asegurar que se refleje en mapa y UI
            redrawAll();
        }

        let editingRouteIdx = null;
        let riverPathPoints = [];
        let tempPolyline = null;
        let tempMarkers = [];
        let originalPolylineHidden = null; // Guardar referencia del polyline original
        let lastEnterTime = 0; // Para detectar doble Enter

        function editRiverRoute(idx) {
            const route = routes[idx];
            if (!route || route.routeType !== 'river') {
                showNotification('‚ö†Ô∏è Solo puedes editar rutas fluviales', 'warning');
                return;
            }
            
            editingRouteIdx = idx;
            riverPathPoints = [];
            
            // IMPORTANTE: Ocultar el polyline original de la ruta mientras se edita
            // Esto evita la duplicaci√≥n visual
            if (polylines[idx]) {
                originalPolylineHidden = polylines[idx];
                map.removeLayer(originalPolylineHidden);
                log(`üôà Polyline original ocultado temporalmente`);
            }
            
            // Si ya tiene geometr√≠a manual, cargar esos puntos
            if (route.manualGeometry && route.manualGeometry.length > 0) {
                riverPathPoints = [...route.manualGeometry];
            } else {
                // Empezar con origen y destino
                const originLL = utmToLatLon(route.origen.x, route.origen.y);
                const destLL = utmToLatLon(route.destino.x, route.destino.y);
                riverPathPoints.push([originLL.lat, originLL.lon]);
                riverPathPoints.push([destLL.lat, destLL.lon]);
            }
            
            // Centrar mapa en la ruta
            const ll = utmToLatLon(route.origen.x, route.origen.y);
            map.setView([ll.lat, ll.lon], 13);
            
            // Mostrar instrucciones mejoradas
            showNotification(`üö§ Editando Ruta ${route.numero}: ARRASTRA v√©rtices para ajustar. Clic en l√≠nea para agregar v√©rtices. Presiona ENTER dos veces o clic derecho para finalizar. ESC para cancelar.`, 'info');
            log(`üìù Modo edici√≥n: Ruta ${route.numero} - Enter x2 o clic derecho para finalizar`);
            
            // Activar modo dibujo
            map.getContainer().style.cursor = 'crosshair';
            
            // Dibujar path temporal inicial
            drawTempRiverPath();
            
            // Mostrar indicador de edici√≥n
            showEditingIndicator();
        }
        
        function showEditingIndicator() {
            // Crear o actualizar el indicador de edici√≥n
            let indicator = document.getElementById('editingIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'editingIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(14, 165, 233, 0.95);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 12px;
                    font-weight: 600;
                    font-size: 0.9rem;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    animation: slideDown 0.3s ease;
                `;
                document.body.appendChild(indicator);
            }
            indicator.innerHTML = `
                <span style="font-size: 1.3rem;">‚úèÔ∏è</span>
                <span style="font-size: 1rem;">Modo Edici√≥n Activo</span>
                <span style="opacity: 0.8; font-size: 0.75rem; margin-left: 5px;">Arrastra los puntos para editar</span>
                <div style="display: flex; gap: 8px; margin-left: 15px; border-left: 1px solid rgba(255,255,255,0.3); padding-left: 15px;">
                    <button onclick="finishEditingRiverRoute()" style="
                        background: #10b981;
                        color: white;
                        border: none;
                        padding: 8px 18px;
                        border-radius: 6px;
                        font-weight: 600;
                        font-size: 0.85rem;
                        cursor: pointer;
                        transition: all 0.2s;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.4);
                    " onmouseover="this.style.background='#059669'; this.style.transform='scale(1.05)'" 
                       onmouseout="this.style.background='#10b981'; this.style.transform='scale(1)'">
                        <span style="font-size: 1.1rem;">üíæ</span>
                        <span>Guardar Ruta</span>
                    </button>
                    <button onclick="cancelEditingRiverRoute()" style="
                        background: #ef4444;
                        color: white;
                        border: none;
                        padding: 8px 18px;
                        border-radius: 6px;
                        font-weight: 600;
                        font-size: 0.85rem;
                        cursor: pointer;
                        transition: all 0.2s;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
                    " onmouseover="this.style.background='#dc2626'; this.style.transform='scale(1.05)'" 
                       onmouseout="this.style.background='#ef4444'; this.style.transform='scale(1)'">
                        <span style="font-size: 1.1rem;">‚úï</span>
                        <span>Cancelar</span>
                    </button>
                </div>
            `;
            indicator.style.display = 'flex';
        }
        
        function hideEditingIndicator() {
            const indicator = document.getElementById('editingIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        function drawTempRiverPath() {
            // Limpiar marcadores anteriores
            tempMarkers.forEach(m => map.removeLayer(m));
            tempMarkers = [];
            
            if (riverPathPoints.length > 1) {
                // Si el polyline ya existe, solo actualizar coordenadas
                if (tempPolyline) {
                    tempPolyline.setLatLngs(riverPathPoints);
                } else {
                    // Crear polyline interactiva solo la primera vez
                    tempPolyline = L.polyline(riverPathPoints, {
                        color: RIVER_COLOR,
                        weight: 6,
                        opacity: 0.8,
                        dashArray: '15, 10'
                    }).addTo(map);
                    
                    // Variables para arrastre de segmento
                    let isDraggingSegment = false;
                    let newVertexIdx = -1;
                    let draggedMarker = null;
                    
                    // Evento mousedown en la l√≠nea para iniciar arrastre de segmento
                    tempPolyline.on('mousedown', (e) => {
                        L.DomEvent.stopPropagation(e);
                        
                        // Verificar que no se hizo clic en un v√©rtice existente
                        const clickPoint = e.latlng;
                        let clickedOnVertex = false;
                        for (let i = 0; i < tempMarkers.length; i++) {
                            const markerPos = tempMarkers[i].getLatLng();
                            const dist = map.distance([clickPoint.lat, clickPoint.lng], [markerPos.lat, markerPos.lng]);
                            if (dist < 20) { // 20 metros de tolerancia
                                clickedOnVertex = true;
                                break;
                            }
                        }
                        
                        if (clickedOnVertex) return; // Si hizo clic en un v√©rtice, dejar que el v√©rtice maneje el evento
                        
                        // Encontrar el segmento m√°s cercano
                        let minDist = Infinity;
                        let insertIdx = -1;
                        
                        for (let i = 0; i < riverPathPoints.length - 1; i++) {
                            const p1 = riverPathPoints[i];
                            const p2 = riverPathPoints[i + 1];
                            
                            // Calcular distancia del clic al segmento
                            const dist = distanceToSegment(
                                [clickPoint.lat, clickPoint.lng],
                                p1,
                                p2
                            );
                            
                            if (dist < minDist) {
                                minDist = dist;
                                insertIdx = i + 1; // Insertar despu√©s del punto i
                            }
                        }
                        
                        if (insertIdx !== -1 && minDist < 50) { // 50 metros de tolerancia
                            // Insertar nuevo v√©rtice en la posici√≥n del clic
                            riverPathPoints.splice(insertIdx, 0, [clickPoint.lat, clickPoint.lng]);
                            newVertexIdx = insertIdx;
                            
                            // Actualizar polyline (no recrear)
                            tempPolyline.setLatLngs(riverPathPoints);
                            
                            // Redibujar SOLO marcadores (no recrear polyline)
                            updateTempMarkers();
                            
                            // Iniciar arrastre del nuevo v√©rtice
                            isDraggingSegment = true;
                            draggedMarker = tempMarkers[newVertexIdx];
                            map.dragging.disable();
                            
                            log(`‚ûï Nuevo v√©rtice creado en posici√≥n ${insertIdx}`);
                        }
                    });
                    
                    // Evento mousemove para arrastrar el nuevo v√©rtice
                    const onMouseMove = (e) => {
                        if (isDraggingSegment && newVertexIdx !== -1) {
                            // Actualizar posici√≥n del nuevo v√©rtice
                            riverPathPoints[newVertexIdx] = [e.latlng.lat, e.latlng.lng];
                            
                            // Actualizar polyline (IMPORTANTE: NO recrear)
                            tempPolyline.setLatLngs(riverPathPoints);
                            
                            // Actualizar marcador
                            if (draggedMarker) {
                                draggedMarker.setLatLng([e.latlng.lat, e.latlng.lng]);
                            }
                        }
                    };
                    
                    // Evento mouseup para terminar arrastre
                    const onMouseUp = (e) => {
                        if (isDraggingSegment) {
                            isDraggingSegment = false;
                            newVertexIdx = -1;
                            draggedMarker = null;
                            map.dragging.enable();
                            
                            // Calcular nueva distancia
                            let totalDist = 0;
                            for (let j = 0; j < riverPathPoints.length - 1; j++) {
                                const p1 = riverPathPoints[j];
                                const p2 = riverPathPoints[j + 1];
                                const dist = map.distance(p1, p2);
                                totalDist += dist;
                            }
                            log(`‚úÖ Segmento ajustado - Nueva distancia: ${(totalDist/1000).toFixed(2)} km`);
                        }
                    };
                    
                    map.on('mousemove', onMouseMove);
                    map.on('mouseup', onMouseUp);
                    
                    // Limpiar eventos al salir de modo edici√≥n
                    tempPolyline._cleanupEvents = () => {
                        map.off('mousemove', onMouseMove);
                        map.off('mouseup', onMouseUp);
                    };
                }
                
                // Agregar marcadores ARRASTRABLES en cada punto
                updateTempMarkers();
            }
        }
        
        // Nueva funci√≥n auxiliar para actualizar solo los marcadores
        function updateTempMarkers() {
            // Limpiar marcadores anteriores
            tempMarkers.forEach(m => map.removeLayer(m));
            tempMarkers = [];
            
            for (let i = 0; i < riverPathPoints.length; i++) {
                const isStartOrEnd = (i === 0 || i === riverPathPoints.length - 1);
                
                // Crear marcador arrastrable
                const marker = L.marker(riverPathPoints[i], {
                    draggable: true,
                    icon: L.divIcon({
                        className: 'vertex-marker',
                        html: `<div style="width:${isStartOrEnd ? 16 : 12}px;height:${isStartOrEnd ? 16 : 12}px;background:${isStartOrEnd ? '#10b981' : RIVER_COLOR};border:2px solid white;border-radius:50%;cursor:move;box-shadow:0 2px 4px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [isStartOrEnd ? 16 : 12, isStartOrEnd ? 16 : 12],
                        iconAnchor: [isStartOrEnd ? 8 : 6, isStartOrEnd ? 8 : 6]
                    })
                }).addTo(map);
                
                // Evento cuando se empieza a arrastrar v√©rtice
                marker.on('dragstart', (e) => {
                    map.getContainer().style.cursor = 'grabbing';
                });
                
                // Evento mientras se arrastra v√©rtice
                marker.on('drag', (e) => {
                    const idx = tempMarkers.indexOf(marker);
                    if (idx !== -1) {
                        riverPathPoints[idx] = [e.latlng.lat, e.latlng.lng];
                        // IMPORTANTE: Solo actualizar coordenadas, no recrear
                        if (tempPolyline) {
                            tempPolyline.setLatLngs(riverPathPoints);
                        }
                    }
                });
                
                // Evento cuando termina de arrastrar v√©rtice
                marker.on('dragend', (e) => {
                    const idx = tempMarkers.indexOf(marker);
                    if (idx !== -1) {
                        riverPathPoints[idx] = [e.latlng.lat, e.latlng.lng];
                        // IMPORTANTE: Solo actualizar coordenadas, no recrear
                        if (tempPolyline) {
                            tempPolyline.setLatLngs(riverPathPoints);
                        }
                        let totalDist = 0;
                        for (let j = 0; j < riverPathPoints.length - 1; j++) {
                            const p1 = riverPathPoints[j];
                            const p2 = riverPathPoints[j + 1];
                            const dist = map.distance(p1, p2);
                            totalDist += dist;
                        }
                        log(`  V√©rtice ${idx} movido - Nueva distancia: ${(totalDist/1000).toFixed(2)} km`);
                    }
                    map.getContainer().style.cursor = 'crosshair';
                });
                
                // Clic para eliminar (solo puntos intermedios)
                if (!isStartOrEnd) {
                    marker.on('click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        if (editingRouteIdx !== null) {
                            removeRiverPoint(i);
                        }
                    });
                }
                
                // Tooltip
                const tooltipText = isStartOrEnd ? 
                    (i === 0 ? 'Origen (arrastrar)' : 'Destino (arrastrar)') : 
                    'Arrastrar o clic para eliminar';
                marker.bindTooltip(tooltipText, {
                    permanent: false,
                    direction: 'top',
                    offset: [0, -8]
                });
                
                tempMarkers.push(marker);
            }
        }
        
        // Funci√≥n auxiliar: calcular distancia de un punto a un segmento
        function distanceToSegment(point, segStart, segEnd) {
            const [px, py] = point;
            const [x1, y1] = segStart;
            const [x2, y2] = segEnd;
            
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            
            // Retornar distancia en metros aproximada
            return Math.sqrt(dx * dx + dy * dy) * 111000; // Conversi√≥n aproximada grados a metros
        }

        function removeRiverPoint(idx) {
            if (riverPathPoints.length <= 2) {
                showNotification('‚ö†Ô∏è Necesitas al menos 2 puntos (origen y destino)', 'warning');
                return;
            }
            riverPathPoints.splice(idx, 1);
            
            // Actualizar polyline sin recrear
            if (tempPolyline) {
                tempPolyline.setLatLngs(riverPathPoints);
            }
            
            // Solo actualizar marcadores
            updateTempMarkers();
        }

        function finishEditingRiverRoute() {
            if (editingRouteIdx === null) return;
            
            const route = routes[editingRouteIdx];
            
            // Guardar geometr√≠a
            route.manualGeometry = [...riverPathPoints];
            
            // Calcular distancia real siguiendo el path
            let totalDist = 0;
            for (let i = 0; i < riverPathPoints.length - 1; i++) {
                const p1 = riverPathPoints[i];
                const p2 = riverPathPoints[i + 1];
                const dist = map.distance(p1, p2);
                totalDist += dist;
            }
            route.distanciaCalculada = totalDist / 1000; // Convertir a km
            route.mode = 'manual';
            
            log(`‚úÖ Ruta ${route.numero} actualizada: ${route.distanciaCalculada.toFixed(2)} km (${riverPathPoints.length} puntos)`);
            showNotification(`‚úÖ Ruta ${route.numero} guardada: ${route.distanciaCalculada.toFixed(2)} km`, 'success');
            
            // Limpiar eventos primero
            if (tempPolyline && tempPolyline._cleanupEvents) {
                tempPolyline._cleanupEvents();
            }
            
            // Limpiar elementos del mapa
            if (tempPolyline) {
                map.removeLayer(tempPolyline);
                tempPolyline = null;
            }
            tempMarkers.forEach(m => map.removeLayer(m));
            tempMarkers = [];
            riverPathPoints = [];
            
            // Restaurar el polyline original si exist√≠a (aunque ser√° redibujado)
            originalPolylineHidden = null;
            
            editingRouteIdx = null;
            map.getContainer().style.cursor = '';
            map.dragging.enable();
            
            // Ocultar indicador de edici√≥n
            hideEditingIndicator();
            
            // Redibujar todo para mostrar la ruta actualizada
            redrawAll();
        }

        function cancelEditingRiverRoute() {
            if (editingRouteIdx === null) return;
            
            showNotification('‚ùå Edici√≥n cancelada', 'info');
            
            // Limpiar eventos de la polyline primero
            if (tempPolyline && tempPolyline._cleanupEvents) {
                tempPolyline._cleanupEvents();
            }
            
            // Limpiar elementos del mapa
            if (tempPolyline) {
                map.removeLayer(tempPolyline);
                tempPolyline = null;
            }
            tempMarkers.forEach(m => map.removeLayer(m));
            tempMarkers = [];
            riverPathPoints = [];
            
            // Restaurar el polyline original que estaba oculto
            if (originalPolylineHidden) {
                map.addLayer(originalPolylineHidden);
                log(`üëÅÔ∏è Polyline original restaurado`);
            }
            originalPolylineHidden = null;
            
            editingRouteIdx = null;
            map.getContainer().style.cursor = '';
            map.dragging.enable();
            
            // Ocultar indicador de edici√≥n
            hideEditingIndicator();
        }

        // Event listener para clics en el mapa durante edici√≥n
        map.on('click', function(e) {
            if (editingRouteIdx !== null) {
                // Agregar punto antes del √∫ltimo (destino)
                const newPoint = [e.latlng.lat, e.latlng.lng];
                riverPathPoints.splice(riverPathPoints.length - 1, 0, newPoint);
                
                // Actualizar polyline sin recrear
                if (tempPolyline) {
                    tempPolyline.setLatLngs(riverPathPoints);
                }
                
                // Solo actualizar marcadores
                updateTempMarkers();
                
                log(`  Punto agregado: ${e.latlng.lat.toFixed(5)}, ${e.latlng.lng.toFixed(5)}`);
            }
        });

        // Event listener para clic derecho (finalizar)
        map.on('contextmenu', function(e) {
            if (editingRouteIdx !== null) {
                L.DomEvent.preventDefault(e);
                finishEditingRiverRoute();
            }
        });

        function redrawAll() { clearRoutes(); drawAllRoutes(); }

        function clearRoutes() {
            markers.forEach(m => map.removeLayer(m));
            polylines.forEach(p => map.removeLayer(p));
            markers = [];
            polylines = [];
            // Limpiar referencias por ruta (para que UI detecte correctamente rutas sin geometr√≠a)
            routes.forEach(r => {
                r._polyline = null;
                r._originMarker = null;
            });
        }

        function clearAll() {
            if (routes.length > 0 && !confirm('¬øLimpiar todas las rutas?')) return;
            routes = [];
            ieEje = null;
            clearRoutes();
            if (zoomMarker) { map.removeLayer(zoomMarker); zoomMarker = null; }
            document.getElementById('ieInfoSection').style.display = 'none';
            updateUI();
            showNotification('üóëÔ∏è Todo limpiado', 'info');
        }

        function centerMap() {
            if (markers.length === 0) return;
            const bounds = L.latLngBounds(markers.map(m => m.getLatLng()));
            map.fitBounds(bounds, { padding: [30, 30] });
        }

        // ==================== MODAL & MANUAL ROUTE ====================
        
        // Variables para el arrastre del modal
        let isDraggingModal = false;
        let modalOffsetX = 0;
        let modalOffsetY = 0;
        let modalCurrentX = 0;
        let modalCurrentY = 0;

        function openModal() {
            const overlay = document.getElementById('modalOverlay');
            const modal = document.getElementById('draggableModal');
            
            overlay.classList.add('active');
            
            // Centrar modal en la pantalla
            setTimeout(() => {
                const rect = modal.getBoundingClientRect();
                modalCurrentX = (window.innerWidth - rect.width) / 2;
                modalCurrentY = (window.innerHeight - rect.height) / 2;
                modal.style.left = modalCurrentX + 'px';
                modal.style.top = modalCurrentY + 'px';
            }, 10);
            
            resetManualDrawingSystem();
            initModalDragging();
        }

        function closeModal() { 
            document.getElementById('modalOverlay').classList.remove('active');
            resetManualDrawingSystem();
        }

        function initModalDragging() {
            const modal = document.getElementById('draggableModal');
            const header = document.getElementById('modalHeader');
            
            // Prevenir selecci√≥n de texto durante el arrastre
            header.addEventListener('selectstart', (e) => e.preventDefault());
            
            header.addEventListener('mousedown', startDragging);
            document.addEventListener('mousemove', dragModal);
            document.addEventListener('mouseup', stopDragging);
            
            // Touch events para m√≥viles
            header.addEventListener('touchstart', startDraggingTouch);
            document.addEventListener('touchmove', dragModalTouch);
            document.addEventListener('touchend', stopDragging);
        }

        function startDragging(e) {
            if (e.target.classList.contains('modal-close')) return;
            
            isDraggingModal = true;
            const modal = document.getElementById('draggableModal');
            const rect = modal.getBoundingClientRect();
            
            modalOffsetX = e.clientX - rect.left;
            modalOffsetY = e.clientY - rect.top;
            
            modal.style.transition = 'none';
        }

        function startDraggingTouch(e) {
            if (e.target.classList.contains('modal-close')) return;
            
            isDraggingModal = true;
            const modal = document.getElementById('draggableModal');
            const rect = modal.getBoundingClientRect();
            const touch = e.touches[0];
            
            modalOffsetX = touch.clientX - rect.left;
            modalOffsetY = touch.clientY - rect.top;
            
            modal.style.transition = 'none';
        }

        function dragModal(e) {
            if (!isDraggingModal) return;
            
            e.preventDefault();
            const modal = document.getElementById('draggableModal');
            
            modalCurrentX = e.clientX - modalOffsetX;
            modalCurrentY = e.clientY - modalOffsetY;
            
            // Limitar a los bordes de la ventana
            const maxX = window.innerWidth - modal.offsetWidth;
            const maxY = window.innerHeight - modal.offsetHeight;
            
            modalCurrentX = Math.max(0, Math.min(modalCurrentX, maxX));
            modalCurrentY = Math.max(0, Math.min(modalCurrentY, maxY));
            
            modal.style.left = modalCurrentX + 'px';
            modal.style.top = modalCurrentY + 'px';
        }

        function dragModalTouch(e) {
            if (!isDraggingModal) return;
            
            e.preventDefault();
            const modal = document.getElementById('draggableModal');
            const touch = e.touches[0];
            
            modalCurrentX = touch.clientX - modalOffsetX;
            modalCurrentY = touch.clientY - modalOffsetY;
            
            // Limitar a los bordes de la ventana
            const maxX = window.innerWidth - modal.offsetWidth;
            const maxY = window.innerHeight - modal.offsetHeight;
            
            modalCurrentX = Math.max(0, Math.min(modalCurrentX, maxX));
            modalCurrentY = Math.max(0, Math.min(modalCurrentY, maxY));
            
            modal.style.left = modalCurrentX + 'px';
            modal.style.top = modalCurrentY + 'px';
        }

        function stopDragging() {
            isDraggingModal = false;
        }

        function resetManualDrawingSystem() {
            // Limpiar puntos fijados
            fixedPoints.forEach(point => {
                if (point.marker) map.removeLayer(point.marker);
            });
            fixedPoints = [];
            
            // Limpiar marcador de preview
            if (previewMarker) {
                map.removeLayer(previewMarker);
                previewMarker = null;
            }
            
            // Limpiar polyline
            if (manualPolyline) {
                map.removeLayer(manualPolyline);
                manualPolyline = null;
            }
            
            // Resetear modo de edici√≥n
            editMode = false;
            
            // Limpiar batch
            batchRoutes = [];
            
            // Resetear formulario
            document.getElementById('routeForm').reset();
            document.getElementById('fixedPointsPanel').style.display = 'none';
            document.getElementById('batchRoutesPanel').style.display = 'none';
            updateFixedPointsUI();
            updateBatchRoutesUI();
            updateButtonStates();
        }

        // ==================== SISTEMA DE PUNTOS MANUALES ====================
        
        // Ir a punto (zoom)
        function goToPoint() {
            const x = parseFloat(document.getElementById('currentX').value);
            const y = parseFloat(document.getElementById('currentY').value);
            
            if (isNaN(x) || isNaN(y)) {
                showNotification('‚ö†Ô∏è Ingresa coordenadas v√°lidas', 'error');
                return;
            }
            
            // Validar coordenadas
            const validation = validateCoordinates(x, y, 'Preview');
            if (!validation.isValid) {
                showNotification('‚ö†Ô∏è ' + validation.errors[0], 'error');
                return;
            }
            
            // Convertir a lat/lon
            const latLon = utmToLatLon(x, y);
            
            // Eliminar marcador de preview anterior
            if (previewMarker) {
                map.removeLayer(previewMarker);
            }
            
            // Crear nuevo marcador de preview
            const previewIcon = L.divIcon({
                className: 'preview-marker',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            previewMarker = L.marker([latLon.lat, latLon.lon], { icon: previewIcon })
                .addTo(map)
                .bindPopup(`<b>üìç Vista Previa</b><br>X: ${x.toFixed(0)}<br>Y: ${y.toFixed(0)}`);
            
            // Hacer zoom al punto
            map.setView([latLon.lat, latLon.lon], 16);
            showNotification('üîç Vista previa del punto', 'info');
        }
        
        // Fijar punto en el mapa
        function fixPoint() {
            const x = parseFloat(document.getElementById('currentX').value);
            const y = parseFloat(document.getElementById('currentY').value);
            
            if (isNaN(x) || isNaN(y)) {
                showNotification('‚ö†Ô∏è Ingresa coordenadas v√°lidas', 'error');
                return;
            }
            
            // Validar coordenadas
            const validation = validateCoordinates(x, y, 'Punto ' + (fixedPoints.length + 1));
            if (!validation.isValid) {
                showNotification('‚ö†Ô∏è ' + validation.errors[0], 'error');
                return;
            }
            
            // Convertir a lat/lon
            const latLon = utmToLatLon(x, y);
            
            // Determinar etiqueta del punto
            const pointNumber = fixedPoints.length + 1;
            let label = pointNumber.toString();
            let markerClass = 'fixed-point-marker';
            
            if (pointNumber === 1) {
                label = 'üö©'; // Origen
                markerClass += ' origin';
            }
            
            // Crear marcador
            const markerIcon = L.divIcon({
                className: markerClass,
                html: `<div>${label}</div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            const marker = L.marker([latLon.lat, latLon.lon], { 
                icon: markerIcon,
                draggable: false // Por defecto no es arrastrable
            }).addTo(map);
            
            marker.bindPopup(`<b>Punto ${pointNumber}</b><br>X: ${x.toFixed(0)}<br>Y: ${y.toFixed(0)}`);
            
            // Agregar a array de puntos
            const point = {
                lat: latLon.lat,
                lon: latLon.lon,
                x: x,
                y: y,
                marker: marker,
                label: pointNumber,
                markerClass: markerClass
            };
            
            fixedPoints.push(point);
            
            // Eliminar marcador de preview
            if (previewMarker) {
                map.removeLayer(previewMarker);
                previewMarker = null;
            }
            
            // Actualizar polyline
            updateManualPolyline();
            
            // Actualizar UI
            updateFixedPointsUI();
            updateButtonStates();
            
            // Limpiar inputs
            document.getElementById('currentX').value = '';
            document.getElementById('currentY').value = '';
            
            // Actualizar etiqueta del √∫ltimo punto si es el destino
            if (fixedPoints.length >= 2) {
                updateDestinationMarker();
            }
            
            showNotification(`üìç Punto ${pointNumber} fijado`, 'success');
        }
        
        // Actualizar marcador de destino
        function updateDestinationMarker() {
            if (fixedPoints.length < 2) return;
            
            const lastPoint = fixedPoints[fixedPoints.length - 1];
            const markerIcon = L.divIcon({
                className: 'fixed-point-marker destination',
                html: `<div>üèÅ</div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            lastPoint.marker.setIcon(markerIcon);
        }
        
        // Actualizar polyline que conecta los puntos
        function updateManualPolyline() {
            // Eliminar polyline anterior
            if (manualPolyline) {
                map.removeLayer(manualPolyline);
            }
            
            // Si hay al menos 2 puntos, crear polyline
            if (fixedPoints.length >= 2) {
                const latlngs = fixedPoints.map(p => [p.lat, p.lon]);
                manualPolyline = L.polyline(latlngs, {
                    color: '#10b981',
                    weight: 4,
                    opacity: 0.8,
                    dashArray: '10, 5'
                }).addTo(map);
            }
        }
        
        // Actualizar UI de puntos fijados
        function updateFixedPointsUI() {
            const panel = document.getElementById('fixedPointsPanel');
            const list = document.getElementById('fixedPointsList');
            const countEl = document.getElementById('pointCount');
            const distanceEl = document.getElementById('routeDistanceCalc');
            
            if (fixedPoints.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            countEl.textContent = fixedPoints.length;
            
            // Calcular distancia total
            let totalDistance = 0;
            for (let i = 0; i < fixedPoints.length - 1; i++) {
                const p1 = fixedPoints[i];
                const p2 = fixedPoints[i + 1];
                const dist = map.distance([p1.lat, p1.lon], [p2.lat, p2.lon]);
                totalDistance += dist;
            }
            distanceEl.textContent = (totalDistance / 1000).toFixed(2);
            
            // Actualizar lista
            list.innerHTML = '';
            fixedPoints.forEach((point, index) => {
                const item = document.createElement('div');
                item.className = 'fixed-point-item';
                
                let pointLabel = `Punto ${point.label}`;
                if (index === 0) pointLabel = 'üö© Origen';
                if (index === fixedPoints.length - 1 && fixedPoints.length > 1) pointLabel = 'üèÅ Destino';
                
                item.innerHTML = `
                    <span class="point-label">${pointLabel}</span>
                    <span class="point-coords">${point.x.toFixed(0)}, ${point.y.toFixed(0)}</span>
                    ${index !== 0 && index !== fixedPoints.length - 1 ? 
                        `<button class="point-remove" onclick="removePoint(${index})" title="Eliminar punto">‚úï</button>` : 
                        ''}
                `;
                
                list.appendChild(item);
            });
        }
        
        // Actualizar estados de botones
        function updateButtonStates() {
            const hasPoints = fixedPoints.length > 0;
            const hasMinimumPoints = fixedPoints.length >= 2;
            const hasBatchRoutes = batchRoutes.length > 0;
            const batchNotFull = batchRoutes.length < MAX_BATCH_ROUTES;
            
            document.getElementById('editVerticesBtn').disabled = !hasPoints;
            document.getElementById('undoBtn').disabled = !hasPoints;
            document.getElementById('clearBtn').disabled = !hasPoints;
            
            // Habilitar "Agregar Ruta" si hay m√≠nimo 2 puntos y el batch no est√° lleno
            document.getElementById('addRouteBatchBtn').disabled = !hasMinimumPoints || !batchNotFull;
            
            // Habilitar "Guardar Todo" si hay rutas en el batch
            document.getElementById('saveAllRoutesBtn').disabled = !hasBatchRoutes;
            
            // Actualizar contador en bot√≥n
            document.getElementById('batchCount').textContent = batchRoutes.length;
        }
        
        // Eliminar un punto espec√≠fico
        function removePoint(index) {
            if (index === 0 || index === fixedPoints.length - 1) {
                showNotification('‚ö†Ô∏è No puedes eliminar el origen o destino', 'error');
                return;
            }
            
            const point = fixedPoints[index];
            map.removeLayer(point.marker);
            fixedPoints.splice(index, 1);
            
            updateManualPolyline();
            updateFixedPointsUI();
            updateButtonStates();
            
            showNotification('üóëÔ∏è Punto eliminado', 'info');
        }
        
        // Deshacer √∫ltimo punto
        function undoLastPoint() {
            if (fixedPoints.length === 0) return;
            
            const lastPoint = fixedPoints.pop();
            map.removeLayer(lastPoint.marker);
            
            // Si qued√≥ m√°s de un punto, actualizar el marcador de destino
            if (fixedPoints.length >= 2) {
                updateDestinationMarker();
            }
            
            updateManualPolyline();
            updateFixedPointsUI();
            updateButtonStates();
            
            showNotification('‚Ü©Ô∏è √öltimo punto eliminado', 'info');
        }
        
        // Limpiar todos los puntos
        function clearAllPoints() {
            if (fixedPoints.length === 0) return;
            
            if (confirm('¬øEst√°s seguro de limpiar todos los puntos?')) {
                fixedPoints.forEach(point => map.removeLayer(point.marker));
                fixedPoints = [];
                
                if (manualPolyline) {
                    map.removeLayer(manualPolyline);
                    manualPolyline = null;
                }
                
                updateFixedPointsUI();
                updateButtonStates();
                
                showNotification('üóëÔ∏è Todos los puntos eliminados', 'info');
            }
        }
        
        // Toggle modo de edici√≥n de v√©rtices
        function toggleEditVertices() {
            editMode = !editMode;
            const btn = document.getElementById('editVerticesBtn');
            
            if (editMode) {
                btn.classList.add('btn-primary');
                btn.classList.remove('btn-secondary');
                btn.textContent = '‚úèÔ∏è Editando...';
                
                // Hacer todos los marcadores arrastrables
                fixedPoints.forEach(point => {
                    point.marker.dragging.enable();
                    
                    // Eventos de arrastre
                    point.marker.on('dragstart', () => {
                        isDraggingPoint = true;
                    });
                    
                    point.marker.on('drag', (e) => {
                        const newLatLng = e.target.getLatLng();
                        const pointIndex = fixedPoints.findIndex(p => p.marker === e.target);
                        
                        if (pointIndex !== -1) {
                            fixedPoints[pointIndex].lat = newLatLng.lat;
                            fixedPoints[pointIndex].lon = newLatLng.lng;
                            
                            // Convertir a UTM
                            const utm = latLonToUtm(newLatLng.lat, newLatLng.lng);
                            fixedPoints[pointIndex].x = utm.x;
                            fixedPoints[pointIndex].y = utm.y;
                            
                            // Actualizar polyline en tiempo real
                            updateManualPolyline();
                        }
                    });
                    
                    point.marker.on('dragend', () => {
                        isDraggingPoint = false;
                        updateFixedPointsUI();
                        showNotification('üìç Punto actualizado', 'success');
                    });
                });
                
                showNotification('‚úèÔ∏è Modo edici√≥n activado - Arrastra los puntos', 'info');
            } else {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                btn.textContent = '‚úèÔ∏è Editar V√©rtices';
                
                // Desactivar arrastre
                fixedPoints.forEach(point => {
                    point.marker.dragging.disable();
                    point.marker.off('dragstart');
                    point.marker.off('drag');
                    point.marker.off('dragend');
                });
                
                showNotification('‚úèÔ∏è Modo edici√≥n desactivado', 'info');
            }
        }
        
        // ==================== BATCH ROUTES SYSTEM ====================
        
        // Agregar ruta al batch
        function addRouteToBatch() {
            console.log('=== addRouteToBatch called ===');
            console.log('Fixed points:', fixedPoints.length);
            console.log('Batch routes:', batchRoutes.length);
            
            // VALIDACI√ìN 1: Puntos m√≠nimos
            if (fixedPoints.length < 2) {
                const message = `‚ö†Ô∏è Necesitas al menos 2 puntos fijados. Actualmente tienes: ${fixedPoints.length}`;
                showNotification(message, 'error');
                console.log('ERROR: Puntos insuficientes');
                
                // Resaltar campos de coordenadas
                if (fixedPoints.length === 0) {
                    highlightError('currentX');
                } else {
                    showNotification('‚ö†Ô∏è Fija el punto de DESTINO para completar la ruta', 'error');
                }
                return;
            }
            
            // VALIDACI√ìN 2: Batch no lleno
            if (batchRoutes.length >= MAX_BATCH_ROUTES) {
                showNotification(`‚ö†Ô∏è M√°ximo ${MAX_BATCH_ROUTES} rutas por batch`, 'error');
                console.log('ERROR: Batch lleno');
                return;
            }
            
            // VALIDACI√ìN 3: Campos obligatorios
            const routeNumber = document.getElementById('routeNumber').value.trim();
            const beneficiaries = document.getElementById('routeBeneficiaries').value.trim();
            
            console.log('Numero ruta:', routeNumber);
            console.log('Beneficiarios:', beneficiaries);
            
            const errors = [];
            
            if (!routeNumber) {
                errors.push('N√∫mero de Ruta');
                highlightError('routeNumber');
            }
            
            if (!beneficiaries || parseInt(beneficiaries) <= 0) {
                errors.push('Beneficiarios (debe ser mayor a 0)');
                highlightError('routeBeneficiaries');
            }
            
            if (errors.length > 0) {
                showNotification('‚ö†Ô∏è Campos requeridos: ' + errors.join(', '), 'error');
                console.log('ERROR: Campos faltantes:', errors);
                return;
            }
            
            // VALIDACI√ìN 4: Beneficiarios num√©rico v√°lido
            const beneficiariesNum = parseInt(beneficiaries);
            if (isNaN(beneficiariesNum) || beneficiariesNum <= 0) {
                showNotification('‚ö†Ô∏è Beneficiarios debe ser un n√∫mero mayor a 0', 'error');
                highlightError('routeBeneficiaries');
                console.log('ERROR: Beneficiarios inv√°lido');
                return;
            }
            
            // VALIDACI√ìN 5: N√∫mero de ruta duplicado
            const isDuplicate = batchRoutes.some(r => r.numero === routeNumber);
            if (isDuplicate) {
                showNotification(`‚ö†Ô∏è Ya existe una Ruta ${routeNumber} en el batch`, 'error');
                highlightError('routeNumber');
                console.log('ERROR: Ruta duplicada');
                return;
            }
            
            console.log('Validaciones pasadas, calculando distancia...');
            
            // Calcular distancia total
            let totalDistance = 0;
            for (let i = 0; i < fixedPoints.length - 1; i++) {
                const p1 = fixedPoints[i];
                const p2 = fixedPoints[i + 1];
                const dist = map.distance([p1.lat, p1.lon], [p2.lat, p2.lon]);
                totalDistance += dist;
            }
            
            console.log('Distancia calculada:', totalDistance / 1000, 'km');
            
            const route = {
                id: Date.now() + Math.random(),
                numero: routeNumber,
                amieFusionada: document.getElementById('originAmie').value.trim(),
                amieEje: ieEje?.amie || '',
                beneficiarios: beneficiariesNum,
                distancia: 0,
                distanciaCalculada: totalDistance / 1000,
                origen: { 
                    x: fixedPoints[0].x, 
                    y: fixedPoints[0].y 
                },
                destino: { 
                    x: fixedPoints[fixedPoints.length - 1].x, 
                    y: fixedPoints[fixedPoints.length - 1].y 
                },
                transporte: document.getElementById('routeTransport').value,
                routeType: document.getElementById('routeType')?.value || 'terrestrial',
                mode: 'manual',
                manualGeometry: [...fixedPoints.map(p => [p.lat, p.lon])],
                pointsCount: fixedPoints.length
            };
            
            console.log('Ruta creada:', route);
            
            batchRoutes.push(route);
            console.log('Ruta agregada al batch. Total:', batchRoutes.length);
            
            updateBatchRoutesUI();
            resetCurrentRoute();
            
            showNotification(`‚úÖ Ruta ${routeNumber} agregada al batch (${batchRoutes.length}/${MAX_BATCH_ROUTES})`, 'success');
            log(`Ruta ${routeNumber} agregada al batch: ${route.distanciaCalculada.toFixed(2)} km, ${beneficiariesNum} estudiantes`);
            
            console.log('=== addRouteToBatch completed ===');
        }
        
        // Funci√≥n para resaltar campos con error
        function highlightError(fieldId) {
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            // Agregar clase de error temporalmente
            field.style.borderColor = '#ef4444';
            field.style.boxShadow = '0 0 0 3px rgba(239, 68, 68, 0.2)';
            
            // Hacer focus en el campo
            field.focus();
            
            // Quitar resaltado despu√©s de 3 segundos
            setTimeout(() => {
                field.style.borderColor = '';
                field.style.boxShadow = '';
            }, 3000);
        }
        
        // Resetear ruta actual (mantener modal abierto)
        function resetCurrentRoute() {
            // Limpiar puntos fijados del mapa
            fixedPoints.forEach(point => {
                if (point.marker) map.removeLayer(point.marker);
            });
            fixedPoints = [];
            
            // Limpiar marcador de preview
            if (previewMarker) {
                map.removeLayer(previewMarker);
                previewMarker = null;
            }
            
            // Limpiar polyline
            if (manualPolyline) {
                map.removeLayer(manualPolyline);
                manualPolyline = null;
            }
            
            // Resetear modo de edici√≥n
            editMode = false;
            
            // Limpiar solo los campos de la ruta, no todo el formulario
            document.getElementById('routeNumber').value = '';
            document.getElementById('routeBeneficiaries').value = '';
            document.getElementById('originAmie').value = '';
            document.getElementById('currentX').value = '';
            document.getElementById('currentY').value = '';
            
            document.getElementById('fixedPointsPanel').style.display = 'none';
            updateFixedPointsUI();
            updateButtonStates();
        }
        
        // Actualizar UI de rutas en batch
        function updateBatchRoutesUI() {
            const panel = document.getElementById('batchRoutesPanel');
            const list = document.getElementById('batchRoutesList');
            const countEl = document.getElementById('batchRouteCount');
            
            if (batchRoutes.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            countEl.textContent = batchRoutes.length;
            
            list.innerHTML = '';
            batchRoutes.forEach((route, index) => {
                const item = document.createElement('div');
                item.className = 'batch-route-item';
                
                const routeType = route.routeType === 'river' ? 'üö§ Fluvial' : 'üöå Terrestre';
                
                item.innerHTML = `
                    <div class="batch-route-header">
                        <span class="batch-route-number">Ruta ${route.numero}</span>
                        <button class="batch-route-remove" onclick="removeRouteFromBatch(${index})">
                            ‚úï Eliminar
                        </button>
                    </div>
                    <div class="batch-route-info">
                        <span>üë• ${route.beneficiarios} estudiantes</span>
                        <span>üìè ${route.distanciaCalculada.toFixed(2)} km</span>
                        <span>${routeType}</span>
                        <span>üìç ${route.pointsCount} puntos</span>
                    </div>
                `;
                
                list.appendChild(item);
            });
            
            updateButtonStates();
        }
        
        // Eliminar ruta del batch
        function removeRouteFromBatch(index) {
            const route = batchRoutes[index];
            batchRoutes.splice(index, 1);
            updateBatchRoutesUI();
            showNotification(`üóëÔ∏è Ruta ${route.numero} eliminada del batch`, 'info');
        }
        
        // Limpiar batch completo
        function clearBatch() {
            if (batchRoutes.length === 0) return;
            
            if (confirm(`¬øEst√°s seguro de eliminar las ${batchRoutes.length} rutas del batch?`)) {
                batchRoutes = [];
                updateBatchRoutesUI();
                showNotification('üóëÔ∏è Batch limpiado', 'info');
            }
        }
        
        // Guardar todas las rutas del batch
        async function saveAllRoutes() {
            if (batchRoutes.length === 0) {
                showNotification('‚ö†Ô∏è No hay rutas en el batch', 'error');
                return;
            }
            
            showLoading(true, `Guardando ${batchRoutes.length} rutas...`);
            
            try {
                let savedCount = 0;
                
                for (let i = 0; i < batchRoutes.length; i++) {
                    const route = batchRoutes[i];
                    
                    showLoading(true, `Guardando ruta ${i + 1} de ${batchRoutes.length}...`);
                    
                    // Agregar a routes globales
                    routes.push(route);
                    
                    // Dibujar en mapa
                    await drawRoute(route);
                    await sleep(100); // Peque√±a pausa entre rutas
                    
                    savedCount++;
                }
                
                showLoading(false);
                updateUI();
                centerMap();
                
                // Limpiar batch y cerrar modal
                batchRoutes = [];
                closeModal();
                
                showNotification(`‚úÖ ${savedCount} rutas guardadas exitosamente`, 'success');
                log(`Batch guardado: ${savedCount} rutas manuales`);
                
            } catch (err) {
                showLoading(false);
                showNotification('‚ùå Error guardando rutas: ' + err.message, 'error');
                log('ERROR batch: ' + err.message);
            }
        }

        // DEPRECATED: Funci√≥n antigua (ya no se usa)
        async function saveManualRoute(e) {
            // Esta funci√≥n ya no se usa, ahora se usa addRouteToBatch
            e.preventDefault();
            addRouteToBatch();
        }

        // ==================== DRAWING MODE ====================
        function startDrawing(routeId) {
            drawingMode = true;
            drawingRouteId = routeId;
            drawingPoints = [];
            document.getElementById('drawingToolbar').style.display = 'flex';
            map.getContainer().style.cursor = 'crosshair';
        }

        function undoLastPoint() {
            if (drawingPoints.length > 0) { drawingPoints.pop(); updateDrawingPolyline(); }
        }

        function updateDrawingPolyline() {
            if (drawingPolyline) map.removeLayer(drawingPolyline);
            if (drawingPoints.length > 1) { drawingPolyline = L.polyline(drawingPoints, { color: '#fcd116', weight: 5 }).addTo(map); }
        }

        function finishDrawing() {
            if (drawingPoints.length < 2) { showNotification('‚ö†Ô∏è Necesitas al menos 2 puntos', 'error'); return; }
            const route = routes.find(r => r.id === drawingRouteId);
            if (route) { route.manualGeometry = drawingPoints; route.mode = 'manual'; }
            cancelDrawing();
            redrawAll();
        }

        function cancelDrawing() {
            drawingMode = false;
            drawingRouteId = null;
            drawingPoints = [];
            if (drawingPolyline) { map.removeLayer(drawingPolyline); drawingPolyline = null; }
            document.getElementById('drawingToolbar').style.display = 'none';
            map.getContainer().style.cursor = '';
        }

        // ==================== EXPORT ====================
        async function captureMap() {
            const mapEl = document.getElementById('map');
            await new Promise(r => setTimeout(r, 500));
            try {
                const dataUrl = await domtoimage.toJpeg(mapEl, { quality: 0.95, bgcolor: '#ffffff', style: { 'transform': 'none' } });
                return dataUrl;
            } catch (err) {
                console.log('dom-to-image fall√≥, usando html2canvas:', err);
                const canvas = await html2canvas(mapEl, { useCORS: true, scale: 2, logging: false, allowTaint: true });
                return canvas.toDataURL('image/jpeg', 0.95);
            }
        }

        async function exportToJPG() {
            showLoading(true, 'Capturando mapa...');
            try {
                const dataUrl = await captureMap();
                const link = document.createElement('a');
                link.download = `rutas_${ieEje?.amie || 'mapa'}_${new Date().toISOString().slice(0,10)}.jpg`;
                link.href = dataUrl;
                link.click();
                showNotification('üì∑ JPG exportado', 'success');
            } catch (err) { showNotification('Error: ' + err.message, 'error'); }
            finally { showLoading(false); }
        }

        async function exportToPDF() {
            showLoading(true, 'Generando PDF...');
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('l', 'mm', 'a4');
                
                // Bandera Ecuador
                doc.setFillColor(252, 209, 22); doc.rect(0, 0, 297, 8, 'F');
                doc.setFillColor(0, 56, 147); doc.rect(0, 8, 297, 3, 'F');
                doc.setFillColor(206, 17, 38); doc.rect(0, 11, 297, 2, 'F');
                
                // Logo institucional (si existe) - CENTRADO
                try {
                    // Logo: 903x82px = 11:1 ratio
                    // CENTRADO: 160mm ancho x 14.5mm alto
                    doc.addImage('logo.png', 'PNG', 68.5, 15, 160, 14.5);
                } catch(e) { console.log('Logo no disponible en PDF'); }
                
                // Texto institucional debajo del logo
                doc.setFontSize(10);
                doc.setTextColor(139, 69, 19); // Color caf√©/dorado
                doc.setFont(undefined, 'normal');
                doc.text('Ministerio de Educaci√≥n Deporte y Cultura (MINEDEC)', 148.5, 32, { align: 'center' });
                
                // T√≠tulo principal
                doc.setFontSize(16);
                doc.setTextColor(0, 56, 147);
                doc.setFont(undefined, 'bold');
                doc.text('INFORME DE RUTAS DE TRANSPORTE ESCOLAR', 148.5, 40, { align: 'center' });
                
                doc.setFontSize(9);
                doc.setTextColor(100);
                doc.setFont(undefined, 'normal');
                doc.text('', 148.5, 46, { align: 'center' });
                
                let y = 54;
                
                // Informaci√≥n IE Eje
                if (ieEje?.amie) {
                    doc.setFontSize(11);
                    doc.setTextColor(0);
                    doc.setFont(undefined, 'bold');
                    doc.text('IE Eje:', 20, y);
                    doc.setFont(undefined, 'normal');
                    doc.text(`${ieEje.nombre || '-'} (AMIE: ${ieEje.amie})`, 45, y);
                    y += 6;
                    doc.text(`Distrito: ${ieEje.distrito || '-'}`, 20, y);
                }
                
                // Resumen - Usar rutas filtradas si hay filtro activo
                y += 10;
                
                // Filtrar rutas seg√∫n el tipo seleccionado (igual que en drawAllRoutes)
                let pdfRoutes = routes;
                const terrestrialActive = document.getElementById('type-terrestrial').classList.contains('active');
                const riverActive = document.getElementById('type-river').classList.contains('active');
                
                if (terrestrialActive && !riverActive) {
                    pdfRoutes = routes.filter(r => r.routeType !== 'river');
                } else if (riverActive && !terrestrialActive) {
                    pdfRoutes = routes.filter(r => r.routeType === 'river');
                }
                
                const terrestrialCount = pdfRoutes.filter(r => r.routeType !== 'river').length;
                const riverCount = pdfRoutes.filter(r => r.routeType === 'river').length;
                doc.setFont(undefined, 'bold');
                doc.text('Resumen:', 20, y);
                doc.setFont(undefined, 'normal');
                y += 6;
                doc.text(`Rutas Terrestres: ${terrestrialCount} | Rutas Fluviales: ${riverCount} | Estudiantes: ${pdfRoutes.reduce((s,r) => s + r.beneficiarios, 0)} | Distancia total: ${pdfRoutes.reduce((s,r) => s + (r.distanciaCalculada || r.distancia || 0), 0).toFixed(2)} km`, 20, y);
                
                // T√≠tulo del mapa
                y += 12;
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(0, 56, 147);
                
                // Determinar el sufijo del t√≠tulo seg√∫n los filtros activos
                let transportType = '';
                if (terrestrialActive && !riverActive) {
                    transportType = ' DEL TIPO TERRESTRE';
                } else if (riverActive && !terrestrialActive) {
                    transportType = ' DEL TIPO FLUVIAL';
                }
                // Si ambos est√°n activos o ninguno, no agregar sufijo
                
                doc.text('MAPA DE RUTAS DE TRANSPORTE ESCOLAR DE LA', 148.5, y, { align: 'center' });
                y += 6;
                doc.setFontSize(11);
                doc.text(`${ieEje?.nombre || 'SIN NOMBRE'}${transportType}`, 148.5, y, { align: 'center' });
                doc.setFont(undefined, 'normal');
                
                // Capturar mapa
                y += 8;
                showLoading(true, 'Capturando mapa para PDF...');
                const mapDataUrl = await captureMap();
                // Mapa centrado: (297 - 200) / 2 = 48.5mm
                doc.addImage(mapDataUrl, 'JPEG', 48.5, y, 200, 100);
                y += 105;
                
                // Tabla de rutas
                function drawTableHeader(yPos) {
                    doc.setFillColor(0, 56, 147);
                    doc.setTextColor(255);
                    doc.rect(20, yPos - 4, 257, 7, 'F');
                    doc.setFontSize(8);
                    doc.setFont(undefined, 'bold');
                    doc.text('Ruta', 25, yPos);
                    doc.text('Tipo', 45, yPos);
                    doc.text('AMIE', 70, yPos);
                    doc.text('Estud.', 105, yPos);
                    doc.text('D.Excel', 130, yPos);
                    doc.text('D.Calc.', 155, yPos);
                    doc.text('Modo', 180, yPos);
                    doc.text('Transp.', 215, yPos);
                    doc.text('', 250, yPos);
                    return yPos + 6;
                }
                
                doc.setTextColor(0);
                doc.setFont(undefined, 'bold');
                doc.text('Detalle de Rutas:', 20, y);
                y += 6;
                y = drawTableHeader(y);
                doc.setTextColor(0);
                doc.setFont(undefined, 'normal');
                
                const pageHeight = 200;
                pdfRoutes.forEach((r, i) => {
                    if (y > pageHeight) {
                        doc.addPage();
                        y = 20;
                        doc.setFillColor(252, 209, 22); doc.rect(0, 0, 297, 5, 'F');
                        doc.setFillColor(0, 56, 147); doc.rect(0, 5, 297, 2, 'F');
                        doc.setFillColor(206, 17, 38); doc.rect(0, 7, 297, 1, 'F');
                        y = 15;
                        doc.setFontSize(10);
                        doc.setTextColor(0, 56, 147);
                        doc.text('Detalle de Rutas (continuaci√≥n)', 20, y);
                        y += 8;
                        y = drawTableHeader(y);
                        doc.setTextColor(0);
                        doc.setFont(undefined, 'normal');
                    }
                    if (i % 2 === 0) { doc.setFillColor(245, 245, 245); doc.rect(20, y - 3, 257, 6, 'F'); }
                    doc.setFontSize(8);
                    doc.text(String(r.numero), 25, y);
                    doc.text(r.routeType === 'river' ? 'Fluv.' : 'Terr.', 45, y);
                    doc.text(String(r.amieFusionada || '-').substring(0, 15), 70, y);
                    doc.text(String(r.beneficiarios), 108, y);
                    doc.text((r.distancia || 0).toFixed(2), 133, y);
                    doc.text((r.distanciaCalculada || 0).toFixed(2), 158, y);
                    doc.text(r.mode === 'manual' ? 'Man.' : r.mode === 'osrm' ? 'OSRM' : 'L√≠nea', 180, y);
                    doc.text((r.transporte || 'Bus').substring(0, 10), 215, y);
                    y += 6;
                });
                
                // Pie de p√°gina
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(8);
                    doc.setTextColor(128, 128, 128);
                    doc.text(`Generado: ${new Date().toLocaleString('es-EC')} | P√°gina ${i} de ${pageCount}`, 148.5, 205, { align: 'center' });
                }
                
                doc.save(`informe_rutas_${ieEje?.amie || 'export'}_${new Date().toISOString().slice(0,10)}.pdf`);
                showNotification('üìÑ PDF generado', 'success');
            } catch (err) { 
                console.error(err);
                showNotification('Error: ' + err.message, 'error'); 
            }
            finally { showLoading(false); }
        }

        // ==================== UTILS ====================
        function showLoading(show, text = 'Procesando...') {
            document.getElementById('loading').classList.toggle('show', show);
            document.getElementById('loadingText').textContent = text;
        }

        function showNotification(msg, type = 'info') {
            const n = document.getElementById('notification');
            n.textContent = msg;
            n.className = `notification ${type} show`;
            setTimeout(() => n.classList.remove('show'), 4000);
        }

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') { 
                closeModal(); 
                cancelDrawing(); 
                cancelEditingRiverRoute(); 
                if (captureMode) toggleCaptureMode(); 
            }
            
            // Doble Enter para finalizar edici√≥n de ruta
            if (e.key === 'Enter' && editingRouteIdx !== null) {
                const now = Date.now();
                const timeSinceLastEnter = now - lastEnterTime;
                
                if (timeSinceLastEnter < 500) { // 500ms para detectar doble Enter
                    // Es un doble Enter - Finalizar edici√≥n
                    finishEditingRiverRoute();
                    lastEnterTime = 0; // Reset
                    
                    // Feedback visual
                    const indicator = document.getElementById('editingIndicator');
                    if (indicator) {
                        indicator.style.background = 'rgba(16, 185, 129, 0.95)';
                        indicator.innerHTML = `
                            <span style="font-size: 1.2rem;">‚úÖ</span>
                            <span>¬°Guardado!</span>
                        `;
                        setTimeout(() => {
                            indicator.style.display = 'none';
                        }, 1000);
                    }
                } else {
                    // Primer Enter - mostrar feedback
                    lastEnterTime = now;
                    showNotification('‚å®Ô∏è Presiona Enter de nuevo para finalizar', 'info');
                    
                    // Feedback visual en el indicador
                    const indicator = document.getElementById('editingIndicator');
                    if (indicator) {
                        indicator.style.background = 'rgba(252, 209, 22, 0.95)';
                        indicator.innerHTML = `
                            <span style="font-size: 1.2rem;">‚ö°</span>
                            <span>Presiona Enter de nuevo</span>
                        `;
                        
                        // Volver al estado normal despu√©s de 500ms
                        setTimeout(() => {
                            if (editingRouteIdx !== null) {
                                showEditingIndicator(); // Restaurar el indicador completo con botones
                            }
                        }, 500);
                    }
                }
            }
        });
    </script>
</body>
</html>
